<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Netfly</title>
  <style>
:root{
  --bg:#0b0b0c;
  --bg2:#111114;
  --card:rgba(255,255,255,.04);
  --card2:rgba(255,255,255,.06);
  --text:#f5f5f5;
  --muted:#b3b3b3;
  --muted2:#8c8c8c;
  --accent:#ffffff;      /* Netflix red */
  --accent2:#b20710;     /* muted red for danger */
  --border:rgba(255,255,255,.08);
  --shadow:0 18px 45px rgba(0,0,0,.55);
  --shadow2:0 10px 30px rgba(0,0,0,.45);
  --ring:0 0 0 3px rgba(255,255,255,.22);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  color:var(--text);

  /* Balanced red ambience: visible but not aggressive */
  background:
    radial-gradient(1200px 600px at 18% -14%, rgba(255,255,255,.20), transparent 70%),
    radial-gradient(1000px 520px at 92% -10%, rgba(255,255,255,.16), transparent 68%),
    radial-gradient(1100px 680px at 50% 120%, rgba(255,255,255,.12), transparent 74%),
    linear-gradient(180deg,
      rgba(255,255,255,.06) 0%,
      rgba(255,255,255,.015) 24%,
      transparent 60%,
      rgba(255,255,255,.05) 100%
    ),
    var(--bg);

  background-attachment: scroll; /* was fixed; changed for smoother inner scrolling */
}

/* Top nav */
.topbar{
  position:sticky;
  top:0;
  z-index:100;
  backdrop-filter: blur(10px);
  background: rgba(0,0,0,.78);
  border-bottom: 1px solid rgba(255,255,255,.06);
}
.topbarInner{
  max-width:1120px;
  margin:0 auto;
  padding: 12px 16px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}
.brandMini{
  font-weight: 950;
  letter-spacing: .4px;
  font-size: 14px;
  display:flex;
  align-items:center;
  gap:10px;
  user-select:none;
}
.brandMini .logoMark{
  width: 10px;
  height: 18px;
  border-radius: 3px;
  background: var(--accent);
  box-shadow: 0 10px 24px rgba(255,255,255,.35);
}
.nav{
  display:flex;
  gap: 16px;
  flex-wrap:wrap;
  align-items:center;
  justify-content:center;
  flex:1;
}
.navBtn{
  border:none;
  background:transparent;
  color: var(--muted);
  padding: 10px 6px;
  cursor:pointer;
  font-weight: 900;
  font-size: 13px;
  letter-spacing:.2px;
  user-select:none;
  position:relative;
  transition: color .16s ease, transform .16s ease;
  white-space:nowrap;
}
.navBtn:hover{ color: var(--text); transform: translateY(-1px); }
.navBtn.active{ color: var(--text); }
.navBtn.active::after{
  content:"";
  position:absolute;
  left:0;
  right:0;
  bottom:2px;
  height:2px;
  background: var(--accent);
  border-radius: 999px;
}

/* Profile dropdown */
.profileWrap{ position: relative; }
.profileBtn{
  width: 42px;
  height: 42px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: var(--text);
  display:grid;
  place-items:center;
  cursor:pointer;
  user-select:none;
  font-size: 18px;
  transition: background .16s ease, border-color .16s ease, transform .16s ease;
}
.profileBtn:hover{
  background: rgba(255,255,255,.10);
  border-color: rgba(255,255,255,.14);
  transform: translateY(-1px);
}
.popover{
  position:absolute;
  right:0;
  top: calc(100% + 10px);
  width: 340px;
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 18px;
  background: rgba(16,16,18,.98);
  box-shadow: var(--shadow);
  overflow:hidden;
  display:none;
}
.popover.show{ display:block; }
.popHead{
  padding: 12px 14px 10px;
  border-bottom: 1px solid rgba(255,255,255,.06);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  font-weight: 950;
}
.popBody{ padding: 12px 14px 14px; }
.statRow{
  display:flex;
  justify-content:space-between;
  gap: 10px;
  padding: 9px 11px;
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 14px;
  background: rgba(255,255,255,.04);
  color: var(--muted);
  font-size: 12px;
  margin-bottom: 8px;
}
.statRow b{ color: var(--text); font-weight: 950; }
.tagList{ display:flex; gap: 8px; flex-wrap:wrap; }
.tagChip{
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  border-radius: 999px;
  padding: 6px 10px;
  font-size: 12px;
  color: var(--muted);
  font-weight: 900;
}

.tagsInline{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center;
}

.reasonInput{
  width:100%;
  min-height: 40px;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(0,0,0,0.28);
  color: #fff;
  outline: none;
}

.reasonInput:focus{
  border-color: rgba(255,255,255,0.55);
  box-shadow: 0 0 0 3px rgba(255,255,255,0.18);
}

.stalePill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding: 6px 10px;
  border-radius: 999px;
  font-weight: 800;
  font-size: 12px;
  letter-spacing: .2px;
  color: rgba(255,255,255,0.92);
  background: rgba(255,255,255,0.14);
  box-shadow: 0 0 0 1px rgba(255,255,255,0.28);
}


.actorChips{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
.actorChip{
  cursor:pointer;
  user-select:none;
  transition: background .16s ease, border-color .16s ease, transform .16s ease, color .16s ease, box-shadow .16s ease;
}
.actorChip:hover{
  border-color: rgba(255,255,255,.55);
  background: rgba(255,255,255,.14);
  color: var(--text);
  box-shadow: var(--ring);
  transform: translateY(-1px);
}
.actorChip:active{ transform: translateY(0px) scale(.99); }

/* Layout */
.wrap{
  max-width:1120px;
  margin: 18px auto 30px;
  padding: 0 16px 30px;
}
.card{
  background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 18px;
  padding: 16px;
  box-shadow: var(--shadow2);
}
.hidden{ display:none !important; }

/* Home */
.homeCenter{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  padding: 26px 0 16px;
  text-align:center;
}
.homeTitle{
  font-size: 46px;
  font-weight: 1000;
  letter-spacing: .7px;
  margin:0;
  line-height:1;
}
.homeTitle .red{ color: var(--accent); }
.homeSub{
  margin-top: 10px;
  color: var(--muted);
  font-size: 13px;
  max-width: 740px;
  line-height: 1.5;
}
.sectionTitle{
  margin: 16px 0 10px;
  font-size: 16px;
  font-weight: 950;
}
.recentGrid{
  display:grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
}
@media (max-width: 980px){ .recentGrid{ grid-template-columns: repeat(2, 1fr);} }
@media (max-width: 520px){ .recentGrid{ grid-template-columns: 1fr; } }

.recentCard{
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  border-radius: 18px;
  padding: 10px;
  cursor:pointer;
  user-select:none;
  transition: transform .16s ease, box-shadow .16s ease, background .16s ease, border-color .16s ease;
  display:flex;
  gap: 10px;
  align-items:stretch;
}
.recentCard:hover{
  background: rgba(255,255,255,.06);
  transform: translateY(-3px);
  box-shadow: var(--shadow2);
  border-color: rgba(255,255,255,.12);
}
.posterSm{
  width: 56px;
  height: 82px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.05);
  overflow:hidden;
  flex-shrink:0;
  display:grid;
  place-items:center;
  color: var(--muted2);
  font-size: 11px;
}
.posterSm img{ width:100%; height:100%; object-fit:cover; display:block; }
.recentTxt{ min-width:0; flex:1; display:flex; flex-direction:column; justify-content:space-between; gap: 8px; }
.recentName{
  margin:0;
  font-size: 14px;
  font-weight: 950;
  line-height: 1.2;
  word-break: break-word;
}
.scoreBadge{
  align-self:flex-start;
  border: 1px solid rgba(255,255,255,.60);
  background: rgba(255,255,255,.16);
  color: var(--text);
  font-weight: 1000;
  font-size: 12px;
  border-radius: 999px;
  padding: 4px 10px;
  font-variant-numeric: tabular-nums;
}
.emptyNote{ color: var(--muted); font-size: 13px; padding: 10px 0; }

/* Form */
label{display:block; font-size: 13px; color: var(--muted); margin-bottom: 6px;}
input[type="text"], input[type="number"], textarea, select{
  width:100%;
  padding: 12px 12px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  color: var(--text);
  outline:none;
  transition: border-color .16s ease, box-shadow .16s ease, background .16s ease;
}
input[type="text"]:focus, input[type="number"]:focus, textarea:focus, select:focus{
  border-color: rgba(255,255,255,.55);
  box-shadow: var(--ring);
  background: rgba(255,255,255,.06);
}
input::placeholder, textarea::placeholder{ color: rgba(179,179,179,.65) }
textarea{min-height: 92px; resize: vertical;}

/* Nicer native dropdowns (select) */
select{
  -webkit-appearance:none;
  -moz-appearance:none;
  appearance:none;
  padding-right: 42px;
  background-image:
    linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01)),
    url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2218%22%20height%3D%2218%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22none%22%20stroke%3D%22%23b3b3b3%22%20stroke-width%3D%222%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%3E%3Cpath%20d%3D%22m6%209%206%206%206-6%22/%3E%3C/svg%3E");
  background-repeat: no-repeat, no-repeat;
  background-position: 0 0, right 12px center;
  background-size: auto, 18px 18px;
}
select option{
  background: rgba(16,16,18,.98);
  color: var(--text);
}

.nameRow{ display:flex; gap: 10px; align-items:stretch; }
@media (max-width: 520px){ .nameRow{flex-direction:column;} }
.formGrid{ display:grid; grid-template-columns: 1.2fr .5fr; gap: 10px; margin-top: 12px; }
@media (max-width: 520px){ .formGrid{grid-template-columns: 1fr;} }
.formGrid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
@media (max-width: 520px){ .formGrid2{grid-template-columns: 1fr;} }

.rows{margin-top: 14px; display:flex; flex-direction:column; gap: 12px;}
.row{
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 16px;
  padding: 12px;
  background: rgba(255,255,255,.03);
}
.rowTop{display:flex; align-items:center; justify-content:space-between; gap: 12px; margin-bottom: 10px;}
.rowTitle{font-size: 14px; margin:0; font-weight: 950;}
.valuePill{
  font-variant-numeric: tabular-nums;
  font-size: 12px;
  padding: 5px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: var(--text);
  min-width: 44px;
  text-align:center;
  font-weight: 950;
}
/* ===== Rating sliders (smoother + nicer) ===== */
.scoreRange{
  --p: 0%;
  -webkit-appearance:none;
  appearance:none;
  width:100%;
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background:
    linear-gradient(to right,
      rgba(255,255,255,.88) 0%,
      rgba(255,255,255,.88) var(--p),
      rgba(255,255,255,.10) var(--p),
      rgba(255,255,255,.10) 100%);
  box-shadow:
    inset 0 1px 0 rgba(0,0,0,.40),
    0 10px 22px rgba(0,0,0,.22);
  outline:none;
  transition: background .14s ease, border-color .14s ease, box-shadow .14s ease;
}
.scoreRange:hover{
  border-color: rgba(255,255,255,.16);
  box-shadow:
    inset 0 1px 0 rgba(0,0,0,.40),
    0 12px 26px rgba(0,0,0,.28);
}
.scoreRange:focus-visible{
  border-color: rgba(255,255,255,.22);
  box-shadow:
    0 0 0 3px rgba(255,255,255,.18),
    inset 0 1px 0 rgba(0,0,0,.40),
    0 12px 28px rgba(0,0,0,.30);
}

/* WebKit */
.scoreRange::-webkit-slider-runnable-track{
  height: 12px;
  border-radius: 999px;
}
.scoreRange::-webkit-slider-thumb{
  -webkit-appearance:none;
  appearance:none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--accent);
  border: 1px solid rgba(255,255,255,.22);
  box-shadow:
    0 8px 18px rgba(0,0,0,.45),
    0 0 0 2px rgba(255,255,255,.24);
  transform: translateY(-3px);
  transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
}
.scoreRange:active::-webkit-slider-thumb{
  transform: translateY(-3px) scale(1.06);
  box-shadow:
    0 10px 22px rgba(0,0,0,.50),
    0 0 0 4px rgba(255,255,255,.28);
}

/* Firefox */
.scoreRange::-moz-range-track{
  height: 12px;
  border-radius: 999px;
  background: rgba(255,255,255,.10);
}
.scoreRange::-moz-range-progress{
  height: 12px;
  border-radius: 999px;
  background: rgba(255,255,255,.88);
}
.scoreRange::-moz-range-thumb{
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--accent);
  border: 1px solid rgba(255,255,255,.22);
  box-shadow:
    0 8px 18px rgba(0,0,0,.45),
    0 0 0 2px rgba(255,255,255,.24);
  transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
}
.scoreRange:active::-moz-range-thumb{
  transform: scale(1.06);
  box-shadow:
    0 10px 22px rgba(0,0,0,.50),
    0 0 0 4px rgba(255,255,255,.28);
}

/* Value pill micro-anim when number changes */
@keyframes valueBump{
  0%{ transform: translateY(0) scale(1); }
  40%{ transform: translateY(-1px) scale(1.06); }
  100%{ transform: translateY(0) scale(1); }
}
.valuePill.bump{ animation: valueBump .16s ease; }


.summary{margin-top: 14px; display:flex; gap: 10px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
.scoreBox{display:flex; gap: 10px; flex-wrap:wrap; align-items:center;}
.score{
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 16px;
  padding: 10px 12px;
  background: rgba(255,255,255,.03);
  min-width: 170px;
}
.score .k{font-size: 12px; color: var(--muted); font-weight: 950;}
.score .v{margin-top: 4px; font-size: 20px; font-weight: 1000; font-variant-numeric: tabular-nums;}

.btns{display:flex; gap: 10px; flex-wrap:wrap; justify-content:flex-end;}
button{
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: var(--text);
  border-radius: 14px;
  padding: 10px 12px;
  cursor:pointer;
  transition: transform .16s ease, background .16s ease, border-color .16s ease, box-shadow .16s ease;
  font-weight: 950;
  user-select:none;
  white-space:nowrap;
}
button:hover{
  background: rgba(255,255,255,.10);
  border-color: rgba(255,255,255,.14);
  transform: translateY(-1px);
}
button:active{ transform: translateY(0px) scale(.99); }

.primary{
  border-color: rgba(255,255,255,.65);
  background: var(--accent);
  box-shadow:
    0 0 0 1px rgba(255,255,255,.20),
    0 0 18px rgba(255,255,255,.18);
}

.primary:hover{
  box-shadow:
    0 0 0 1px rgba(255,255,255,.28),
    0 0 26px rgba(255,255,255,.22);
}
.danger{
  border-color: rgba(255,255,255,.55);
  background: rgba(255,255,255,.20);
}
.danger:hover{
  background: rgba(255,255,255,.28);
  border-color: rgba(255,255,255,.65);
}
.small{font-size: 12px; color: var(--muted);}
.note{margin-top: 10px; font-size: 12px; color: var(--muted);}

/* OMDb dropdown */
.dropdown{ position: relative; }
.results{
  position:absolute;
  top: calc(100% + 8px);
  left:0;
  right:0;
  z-index: 20;
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 16px;
  background: rgba(16,16,18,.98);
  box-shadow: var(--shadow);

  /* scroll the results list (not the page) */
  max-height: clamp(260px, 38vh, 420px);
  overflow-y: auto;
  overflow-x: hidden;
  overscroll-behavior: contain;
  -webkit-overflow-scrolling: touch;
  /* smoother scrolling */
  scroll-behavior: auto;
  transform: translateZ(0);
  contain: layout paint;


  display:none;
}

.results.show{display:block;}
.results::-webkit-scrollbar{ width: 8px; }
.results::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,.16);
  border-radius: 999px;
}
.results::-webkit-scrollbar-thumb:hover{ background: rgba(255,255,255,.24); }

.resItem{
  padding: 10px 12px;
  display:flex;
  gap: 10px;
  align-items:center;
  cursor:pointer;
  border-top: 1px solid rgba(255,255,255,.06);
}
.resItem:first-child{border-top:none;}
.resItem:hover{background: rgba(255,255,255,.06);}
.resTxt{min-width:0;}
.resTitle{font-size: 13px; font-weight: 950; margin:0; line-height:1.15;}
.resSub{margin-top: 3px; font-size: 12px; color: var(--muted);}
.miniThumb{
  width: 30px;
  height: 44px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.05);
  overflow:hidden;
  flex-shrink:0;
  display:grid;
  place-items:center;
  color: var(--muted2);
  font-size: 10px;
}
.miniThumb img{width:100%; height:100%; object-fit:cover; display:block;}
.omdbHint{margin-top: 8px; font-size: 12px; color: var(--muted);}
.omdbHint b{color: var(--text);}

/* Lists */
.listHeader{display:flex; flex-direction:column; gap: 10px; margin-bottom: 12px;}
.listTop{display:flex; align-items:center; justify-content:space-between; gap: 10px;}
.listTop h2{font-size: 16px; margin:0; font-weight: 1000;}
.controls{ display:grid; grid-template-columns: 1fr .75fr; gap: 10px; }
@media (max-width: 520px){ .controls{grid-template-columns: 1fr;} }
.filters{
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 16px;
  padding: 12px;
  background: rgba(255,255,255,.03);
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}
@media (max-width: 620px){ .filters{grid-template-columns: 1fr;} }
.filterRow{display:flex; flex-direction:column; gap: 6px;}
.inline{display:flex; align-items:center; gap: 10px; flex-wrap:wrap;}
.inline input[type="checkbox"]{transform: translateY(1px); accent-color: var(--accent);}

.items{display:flex; flex-direction:column; gap: 10px; /* full page scroll */ max-height:none; overflow:visible; padding-right: 0;}
.empty{color: var(--muted); font-size: 13px; padding: 10px 0;}

/* Tips (AI) */
.tipsGrid{
  display:grid;
  grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.1fr);
  gap: 12px;
}
@media (max-width: 900px){ .tipsGrid{ grid-template-columns: 1fr; } }
.tipsPanel{
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 16px;
  background: rgba(255,255,255,.03);
  padding: 14px;
  display:flex;
  flex-direction:column;
  gap: 10px;
}
.tipsSteps{
  margin: 0;
  padding-left: 18px;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.5;
}
.tipsStatus{
  font-size: 12px;
  color: var(--muted);
}
.tipsOutput{
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.28);
  border-radius: 14px;
  padding: 12px;
  min-height: 140px;
  white-space: pre-wrap;
  line-height: 1.5;
}
.tipsHint{
  font-size: 12px;
  color: var(--muted);
}

/* Film cards */
details.item{
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 18px;
  padding: 0;
  background: rgba(255,255,255,.03);
  overflow:hidden;
  transition: transform .16s ease, box-shadow .16s ease, border-color .16s ease, background .16s ease;
}
/* ===== White outline cinema glow on opened card (edge only) ===== */
details.item{
  position: relative;
}

/* No inner fill, only outline + soft outer glow */
details.item[open]{
  border-color: rgba(255,255,255,.18);
  box-shadow:
    0 0 0 1px rgba(255,255,255,.14),
    0 0 22px rgba(255,255,255,.10),
    0 18px 45px rgba(0,0,0,.55);
}
details.item:hover{
  transform: translateY(-3px);
  box-shadow: var(--shadow2);
  border-color: rgba(255,255,255,.12);
  background: rgba(255,255,255,.045);
}
details.item summary{
  list-style:none;
  cursor:pointer;
  padding: 12px;
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap: 12px;
}
details.item summary::-webkit-details-marker{display:none;}
.sumLeft{min-width:0; display:flex; gap: 12px; align-items:flex-start;}
.sumText{min-width:0;}
.titleLine{display:flex; gap: 8px; align-items:baseline; flex-wrap:wrap;}
.title{
  font-size: 15px;
  font-weight: 1000;
  margin:0;
  line-height:1.15;
  word-break: break-word;
}
.tagPill{
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  padding: 3px 8px;
  border-radius: 999px;
  font-size: 12px;
  color: var(--muted);
  font-variant-numeric: tabular-nums;
  font-weight: 950;
}
.tagPill.red{
  border-color: rgba(255,255,255,.60);
  background: rgba(255,255,255,.16);
  color: var(--text);
}
.metaLine{
  margin-top: 6px;
  color: var(--muted);
  font-size: 12px;
  display:flex;
  gap: 10px;
  flex-wrap:wrap;
  align-items:center;
}
.chip{
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  padding: 4px 8px;
  border-radius: 999px;
  font-variant-numeric: tabular-nums;
  font-weight: 950;
}
.sumRight{display:flex; align-items:center; gap: 10px; flex-shrink:0;}
.arrow{
  width: 38px;
  height: 38px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  display:grid;
  place-items:center;
  font-size: 16px;
  line-height: 1;
  transition: transform .16s ease, background .16s ease, border-color .16s ease;
}
details[open] .arrow{ transform: rotate(180deg); }
details.item summary:hover .arrow{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.14); }

.itemBody{
  padding: 0 12px;
  border-top: 1px solid rgba(255,255,255,.08);
  max-height: 0;
  opacity: 0;
  transform: translateY(-6px);
  overflow: hidden;
  transition: max-height .22s ease, opacity .18s ease, transform .18s ease;
  will-change: max-height, opacity, transform;
}
details[open] .itemBody{
  padding-bottom: 12px;
  max-height: 4000px;
  opacity: 1;
  transform: translateY(0);
}
.infoGrid{
  margin-top: 10px;
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
@media (max-width: 520px){ .infoGrid{grid-template-columns: 1fr;} }

.kv{
  display:flex;
  justify-content:space-between;
  gap: 10px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.04);
  border-radius: 14px;
  padding: 9px 11px;
  font-size: 12px;
  color: var(--muted);
}
.kv b{color: var(--text); font-weight:1000; font-variant-numeric: tabular-nums;}

.textBlock{
  margin-top: 10px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.04);
  border-radius: 14px;
  padding: 10px 11px;
}
.textBlock .k{font-size: 12px; color: var(--muted); margin-bottom: 6px; font-weight: 950;}
.textBlock .v{font-size: 13px; color: var(--text); white-space: pre-wrap; line-height: 1.4;}
.actionsRow{margin-top: 10px; display:flex; justify-content:flex-end; gap: 10px; flex-wrap:wrap;}

.thumb{
  width: 46px;
  height: 70px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.05);
  overflow:hidden;
  flex-shrink:0;
  display:grid;
  place-items:center;
  color: var(--muted2);
  font-size: 11px;
  white-space:pre-line;
  text-align:center;
}
.thumb img{ width:100%; height:100%; object-fit: cover; display:block; }

.posterBig{
  margin-top: 10px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  border-radius: 16px;
  padding: 10px;
  display:flex;
  gap: 12px;
  align-items:flex-start;
  flex-wrap:wrap;
}
.posterBigImg{
  width: 150px;
  height: 225px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.05);
  overflow:hidden;
  flex-shrink:0;
  display:grid;
  place-items:center;
  color: var(--muted2);
  font-size: 12px;
}
.posterBigImg img{ width:100%; height:100%; object-fit: cover; display:block; }
.posterMeta{ min-width: 240px; flex:1; }

@media (max-width: 680px){
  .topbarInner{
    flex-wrap: wrap;
    align-items: center;
  }
  .nav{
    order: 3;
    width: 100%;
    justify-content: flex-start;
    overflow-x: auto;
    padding-bottom: 6px;
  }
  .navBtn{
    padding: 8px 10px;
    font-size: 12px;
  }
  .wrap{
    margin: 10px auto 20px;
  }
  .card{
    padding: 12px;
  }
  .homeTitle{
    font-size: 34px;
  }
  .listTop{
    flex-direction: column;
    align-items: flex-start;
  }
  .nameRow{
    flex-direction: column;
    align-items: stretch;
  }
  .formGrid,
  .formGrid2{
    grid-template-columns: 1fr;
  }
  .rowTop{
    flex-direction: column;
    align-items: flex-start;
  }
  .summary{
    flex-direction: column;
    align-items: flex-start;
  }
  .score{
    min-width: 0;
    width: 100%;
  }
  .btns{
    justify-content: flex-start;
  }
  details.item summary{
    flex-direction: column;
    align-items: flex-start;
  }
  .sumRight{
    width: 100%;
    justify-content: flex-start;
    flex-wrap: wrap;
  }
  .controls{
    grid-template-columns: 1fr !important;
  }
  .posterBig{
    flex-direction: column;
    align-items: stretch;
  }
  .posterBigImg{
    width: min(240px, 100%);
    height: auto;
    aspect-ratio: 2 / 3;
    margin: 0 auto;
  }
  .posterMeta{
    min-width: 0;
  }
  .sessionRow{
    flex-direction: column;
    align-items: flex-start;
  }
  .profileHero{
    flex-direction: column;
    align-items: flex-start;
  }
  .avatarCircle{
    width: 48px;
    height: 48px;
  }
  .profileTitle{
    font-size: 20px;
  }
  .profileSubtitle{
    font-size: 12px;
  }
  .statTiles{
    grid-template-columns: 1fr;
  }
  .profileSection{
    padding: 12px;
  }
  .favGrid{
    grid-template-columns: 1fr;
  }
}

/* Quick actions */
.quickActions{ display:flex; gap: 8px; align-items:center; }
.iconBtn{
  width: 38px;
  height: 38px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  display:grid;
  place-items:center;
  cursor:pointer;
  user-select:none;
  transition: background .16s ease, border-color .16s ease, transform .16s ease;
  font-size: 16px;
  line-height: 1;
  padding:0;
}
/* Kino.pub button inside quickActions */
.iconBtn.kinoBtn{
  position: relative;
  overflow: hidden;
  color: var(--text);


  text-decoration: none;
}

/* убираем дефолтный вид ссылки */
.iconBtn.kinoBtn a{
  color: inherit;
  text-decoration: none;
  display: grid;
  place-items: center;
  width: 100%;
  height: 100%;
}

/* на всякий случай: если браузер применяет visited */
.iconBtn.kinoBtn a:visited{
  color: inherit;

}

.iconBtn.kinoBtn:visited{
  color: var(--text);
}

.iconBtn:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.14); transform: translateY(-1px); }
.iconBtn:active{ transform: translateY(0px) scale(.99); }
.iconBtn.favOn{
  border-color: rgba(255,255,255,.55);
  background: rgba(255,255,255,.16);
}
.iconBtn.dangerMini{
  border-color: rgba(255,255,255,.55);
  background: rgba(255,255,255,.18);
}
.iconBtn.dangerMini:hover{ background: rgba(255,255,255,.26); }

.iconBtn.kinoBtn{
  font-weight: 700;
  font-size: 12px;
  letter-spacing: .6px;
  text-transform: uppercase;
  border-color: rgba(255,255,255,.28);
  background: rgba(255,255,255,.05);
}
.iconBtn.kinoBtn:hover{
  background: rgba(255,255,255,.14);
  border-color: rgba(255,255,255,.40);
}


/* Flash */
.flash{ animation: flashBg 1.2s ease 0s 1; }
@keyframes flashBg{
  0%{ box-shadow: 0 0 0 rgba(255,255,255,0); }


/* ===== Micro feedback: poster/score ping + fade transitions ===== */
@keyframes posterPing{
  0%{ transform: scale(1); box-shadow: none; }
  40%{ transform: scale(1.03); box-shadow: 0 0 0 1px rgba(255,255,255,.14), 0 0 22px rgba(255,255,255,.18); }
  100%{ transform: scale(1); box-shadow: none; }
}
@keyframes scorePing{
  0%{ transform: translateY(0) scale(1); box-shadow: none; }
  45%{ transform: translateY(-1px) scale(1.06); box-shadow: 0 0 0 3px rgba(255,255,255,.22); }
  100%{ transform: translateY(0) scale(1); box-shadow: none; }
}
.pingPoster{ animation: posterPing .18s ease; }
.pingScore{ animation: scorePing .18s ease; }

/* Fade-out transitions for status move / delete */
details.item.leaving{
  opacity: 0;
  transform: translateY(10px);
  transition: opacity .16s ease, transform .16s ease;
}

details.item.removing{
  transition: height .18s ease, opacity .18s ease, transform .18s ease;
}


  25%{ box-shadow: 0 0 0 4px rgba(255,255,255,.35); }
  100%{ box-shadow: 0 0 0 rgba(255,255,255,0); }
}

.imdbLink{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding: 7px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.55);
  background: rgba(255,255,255,.14);
  color: var(--text);
  text-decoration: none;
  font-weight: 1000;
  font-size: 12px;
  line-height: 1;
  transition: background .16s ease, transform .16s ease;
}
.imdbLink:hover{ background: rgba(255,255,255,.20); transform: translateY(-1px); }
.imdbLink:active{ transform: translateY(0px) scale(.99); }
/* Micro animations (lightweight) */
@keyframes fadeUp{
  from{ opacity:0; transform: translateY(8px); }
  to{ opacity:1; transform: translateY(0); }
}
@keyframes favPulse{
  0%{ transform: scale(1); }
  50%{ transform: scale(1.18); }
  100%{ transform: scale(1); }
}
details.item{ animation: fadeUp .18s ease both; }
.recentCard{ animation: fadeUp .18s ease both; }
.iconBtn.pulse{ animation: favPulse .18s ease; }

@media (prefers-reduced-motion: reduce){
  *, *::before, *::after{
    animation: none !important;
    transition: none !important;
    scroll-behavior: auto !important;
  }
}

/* Avoid list flicker on delete/mass rerenders */
body.muteAnim details.item,
body.muteAnim .recentCard,
body.muteAnim .tile,
body.muteAnim .miniItem,
body.muteAnim .favCard{
  animation: none !important;
}
body.muteAnim details.item .itemBody{
  transition: none !important;
}

/* ===== Profile (dashboard) ===== */
.profilePage{ padding: 16px; }
.profileHero{
  display:flex;
  align-items:center;
  gap: 16px;
  padding: 6px 2px 14px;
}
.avatarCircle{
  width: 56px;
  height: 56px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  display:grid;
  place-items:center;
  box-shadow: 0 16px 34px rgba(0,0,0,.45);
  flex-shrink:0;
}
.avatarCircle svg{ width: 26px; height: 26px; opacity:.95; }
.profileTitle{
  margin:0;
  font-size: 22px;
  font-weight: 1000;
  letter-spacing: .2px;
}
.profileSubtitle{
  margin-top: 6px;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.35;
  max-width: 720px;
}
.statTiles{
  margin-top: 6px;
  display:grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
}
@media (max-width: 980px){ .statTiles{ grid-template-columns: repeat(2, 1fr);} }
.tile{
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.04);
  border-radius: 16px;
  padding: 14px 14px 12px;
  box-shadow: 0 16px 34px rgba(0,0,0,.35);
  animation: fadeUp .18s ease both;
}
.tile .n{
  font-size: 28px;
  font-weight: 1000;
  letter-spacing: .2px;
  font-variant-numeric: tabular-nums;
}
.tile .k{
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
  font-weight: 900;
}
.profileSection{
  margin-top: 14px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  border-radius: 16px;
  padding: 14px;
  box-shadow: 0 16px 34px rgba(0,0,0,.30);
  animation: fadeUp .18s ease both;
}
.supabaseStatus{
  margin-top: 6px;
  font-weight: 900;
  color: var(--muted);
}
.supabaseStatus.error{ color: #ff8b8b; }
.secHead{ display:flex; align-items:flex-end; justify-content:space-between; gap: 10px; margin-bottom: 10px; }
.secHead h3{ margin:0; font-size: 14px; font-weight: 1000; }
.genreChips{ display:flex; gap: 8px; flex-wrap:wrap; }
.genreChip{
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.02);
  color: var(--muted);
  border-radius: 999px;
  padding: 6px 10px;
  font-size: 12px;
  font-weight: 900;
  transition: border-color .16s ease, color .16s ease, transform .16s ease, background .16s ease;
}
.genreChip:hover{
  border-color: rgba(255,255,255,.70);
  color: var(--text);
  background: rgba(255,255,255,.10);
  transform: translateY(-1px);
}
.favGrid{
  margin-top: 14px;
  display:grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
}
@media (max-width: 980px){ .favGrid{ grid-template-columns: repeat(2, 1fr);} }
@media (max-width: 520px){ .favGrid{ grid-template-columns: 1fr; } }
.favCard{
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  border-radius: 16px;
  padding: 14px;
  box-shadow: 0 16px 34px rgba(0,0,0,.30);
  min-height: 210px;
  display:flex;
  flex-direction:column;
  gap: 10px;
  animation: fadeUp .18s ease both;
}
.favCard .h{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap: 10px;
}
.favCard .h .t{ font-size: 14px; font-weight: 1000; margin:0; }
.favCard .h .s{ font-size: 12px; color: var(--muted); font-weight: 800; margin-top: 4px; }
.favEmpty{
  flex:1;
  display:flex;
  flex-direction:column;
  justify-content:center;
  gap: 10px;
  color: var(--muted);
  font-size: 13px;
}
.favMovieRow{ display:flex; gap: 12px; align-items:flex-start; }
.favPoster{
  width: 64px;
  height: 96px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  overflow:hidden;
  flex-shrink:0;
  display:grid;
  place-items:center;
  color: var(--muted);
  font-size: 11px;
}
.favPoster img{ width:100%; height:100%; object-fit:cover; display:block; }
.favMeta{ min-width: 0; flex:1; }
.favName{ margin:0; font-weight: 1000; font-size: 14px; line-height: 1.2; }
.favSub{ margin-top: 6px; color: var(--muted); font-size: 12px; display:flex; gap: 8px; flex-wrap:wrap; align-items:center; }
.badgeRed{
  border: 1px solid rgba(255,255,255,.70);
  background: rgba(255,255,255,.16);
  color: var(--text);
  font-weight: 1000;
  font-size: 12px;
  border-radius: 999px;
  padding: 4px 10px;
  font-variant-numeric: tabular-nums;
}
.favStats{
  display:flex;
  gap: 8px;
  flex-wrap:wrap;
}
.favStat{
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  border-radius: 12px;
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
  font-weight: 800;
}
.favStat b{ color: var(--text); font-weight:1000; }
.miniList{ display:flex; flex-direction:column; gap: 10px; }
.miniItem{
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  border-radius: 14px;
  padding: 10px;
  display:flex;
  gap: 10px;
  align-items:center;
  cursor:pointer;
  transition: transform .16s ease, background .16s ease, border-color .16s ease, box-shadow .16s ease;
}
.miniItem:hover{
  transform: translateY(-2px);
  background: rgba(255,255,255,.05);
  box-shadow: 0 18px 40px rgba(0,0,0,.45);
  border-color: rgba(255,255,255,.22);
}
.miniThumb{
  width: 40px;
  height: 58px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  overflow:hidden;
  flex-shrink:0;
  display:grid;
  place-items:center;
  color: var(--muted);
  font-size: 10px;
}
.miniThumb img{ width:100%; height:100%; object-fit:cover; display:block; }
.miniTxt{ min-width:0; flex:1; }
.miniTitle{ margin:0; font-weight:1000; font-size: 13px; line-height: 1.15; }
.miniMeta{ margin-top: 4px; color: var(--muted); font-size: 12px; display:flex; gap: 8px; flex-wrap:wrap; align-items:center; }
.twoCol{
  margin-top: 14px;
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}
@media (max-width: 980px){ .twoCol{ grid-template-columns: 1fr; } }

/* Compact lists inside favorite cards */
.favList{
  margin-top: 8px;
  display:none;
  flex-direction:column;
  gap: 8px;
}
.favList.show{ display:flex; }
.favList .miniItem{ padding: 8px; border-radius: 12px; }
.favList .miniThumb{ width: 34px; height: 50px; border-radius: 10px; }

/* Picker modal */
.modal{
  position:fixed;
  inset:0;
  z-index: 200;
  display:none;
}
.modal.show{ display:block; }
.modalBackdrop{
  position:absolute;
  inset:0;
  background: rgba(0,0,0,.55);
  backdrop-filter: blur(6px);
}
.modalCard{
  position:relative;
  max-width: 720px;
  margin: 8vh auto 0;
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 18px;
  background: rgba(10,10,12,.96);
  box-shadow: 0 26px 60px rgba(0,0,0,.6);
  padding: 14px;
  animation: fadeUp .18s ease both;
}
@media (max-width: 760px){ .modalCard{ margin: 10vh 14px 0; } }
.modalHead{ display:flex; align-items:flex-start; justify-content:space-between; gap: 10px; margin-bottom: 10px; }
.modalTitle{ font-size: 14px; font-weight: 1000; }
.modalList{ margin-top: 10px; max-height: 52vh; overflow:auto; padding-right: 2px; display:flex; flex-direction:column; gap: 8px; }
.profileBtn{
  width: 42px;
  height: 42px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  color: var(--text);
  display:grid;
  place-items:center;
  cursor:pointer;
  transition: background .16s ease, transform .16s ease, box-shadow .16s ease, border-color .16s ease;
}
.profileBtn:hover{
  background: rgba(255,255,255,.14);
  border-color: rgba(255,255,255,.55);
  box-shadow: 0 0 0 3px rgba(255,255,255,.12);
  transform: translateY(-1px);
}
.profileBtn.active{
  border-color: rgba(255,255,255,.70);
  background: rgba(255,255,255,.16);
  box-shadow: 0 0 0 3px rgba(255,255,255,.12);
}
.profileIcon{ display:block; }


/* ===== Wish expanded details layout (poster + meta grid) ===== */
.posterBox{
  width: 180px;
  max-width: 42vw;
  aspect-ratio: 2 / 3;
  border-radius: 14px;
  overflow: hidden;
  background: rgba(255,255,255,.04);
  border: 1px solid rgba(255,255,255,.08);
  display:flex;
  align-items:center;
  justify-content:center;
  color: rgba(255,255,255,.45);
  font-size: 12px;
}
.posterBox img{ width:100%; height:100%; object-fit:cover; display:block; }

.posterMeta{ flex:1; min-width: 240px; display:flex; flex-direction:column; gap:12px; }
.metaGrid{
  display:grid;
  grid-template-columns: repeat(3, minmax(0,1fr));
  gap:10px;
}
@media(max-width:900px){
  .metaGrid{ grid-template-columns: repeat(2, minmax(0,1fr)); }
}
@media(max-width:520px){
  .metaGrid{ grid-template-columns: 1fr; }
}

.orderPill{
  margin-left: 10px;
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  color: rgba(255,255,255,.88);
  background: rgba(255,255,255,.12);
}

/* Wish toggle look */
.wishSegment{ margin-left: 10px; }

/* ===== Netflix polish pack (drop-in) ===== */
:root{
    --parY: 0;
  --glass: rgba(255,255,255,.055);
  --glass2: rgba(255,255,255,.075);
  --line: rgba(255,255,255,.09);
  --glow: 0 0 0 1px rgba(255,255,255,.18), 0 18px 60px rgba(255,255,255,.12);
  --easeOut: cubic-bezier(.18,.9,.18,1);
}

/* Subtle film grain */
body::before{
  content:"";
  position:fixed;
  inset:0;
  pointer-events:none;
  opacity:.06;
  mix-blend-mode: overlay;
  background-image:
    url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='220'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='220' height='220' filter='url(%23n)' opacity='.45'/%3E%3C/svg%3E");
}

/* Glass cards */
.card{
  background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  border: 1px solid var(--line);
  transform: translateZ(0);
  transition: transform .18s var(--easeOut), box-shadow .18s var(--easeOut), border-color .18s var(--easeOut);
}
.card:hover{
  border-color: rgba(255,255,255,.16);
  transform: translateY(-2px);
  box-shadow: 0 18px 60px rgba(0,0,0,.35), 0 0 0 1px rgba(255,255,255,.04);
}
.card:has(button:hover),
.card:has(a:hover){
  box-shadow: 0 18px 60px rgba(0,0,0,.35), var(--glow);
}

/* Buttons feel */
button{
  transition: transform .12s var(--easeOut), filter .12s var(--easeOut), background .12s var(--easeOut);
}
button:active{ transform: translateY(1px) scale(.99); }

/* Focus */
:focus-visible{
  outline: none;
  box-shadow: 0 0 0 2px rgba(255,255,255,.35);
  border-radius: 12px;
}

/* Scrollbars */
*::-webkit-scrollbar{ width: 10px; height: 10px; }
*::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,.12);
  border-radius: 999px;
  border: 2px solid rgba(0,0,0,0);
  background-clip: padding-box;
}
*::-webkit-scrollbar-thumb:hover{ background: rgba(255,255,255,.18); }
*::-webkit-scrollbar-track{ background: rgba(255,255,255,.03); }

/* Chips */
.chip{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.05);
  color: rgba(255,255,255,.72);
  font-weight: 900;
  font-size: 12px;
  letter-spacing:.2px;
}
.chip.red{
  border-color: rgba(255,255,255,.30);
  background: rgba(255,255,255,.12);
  color: #ffd6d8;
}

/* View animation */
.view{
  animation: viewIn .18s var(--easeOut) both;
}
@keyframes viewIn{
  from{ opacity:0; transform: translateY(6px); }
  to{ opacity:1; transform: translateY(0); }
}

/* Modal polish */
.modalCard{
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(15,15,18,.96);
  box-shadow: 0 18px 60px rgba(0,0,0,.35), var(--glow);
  transform: translateY(10px);
  opacity: 0;
  transition: transform .18s var(--easeOut), opacity .18s var(--easeOut);
}
.modal.show .modalCard{
  transform: translateY(0);
  opacity: 1;
}

/* Cinematic overlay for big posters (uses existing Netfly classes) */
.posterBigImg{
  position: relative;
  overflow:hidden;
}
.posterBigImg::after{
  content:"";
  position:absolute;
  inset:0;
  background:
    radial-gradient(120% 80% at 40% 10%, rgba(0,0,0,.20), rgba(0,0,0,.75)),
    linear-gradient(180deg, rgba(0,0,0,.0), rgba(0,0,0,.72));
  pointer-events:none;
}
.posterBigImg img{
  transform: scale(1.02);
  filter: saturate(1.05) contrast(1.05);
  transition: transform .25s var(--easeOut), filter .25s var(--easeOut);
}
.card:hover .posterBigImg img{
  transform: scale(1.05);
  filter: saturate(1.08) contrast(1.08);
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce){
  *{ transition:none !important; animation:none !important; scroll-behavior:auto !important; }
  body::before{ display:none; }
}


/* ===== Toasts ===== */
.toastHost{
  position: fixed;
  right: 14px;
  bottom: 14px;
  z-index: 9999;
  display:flex;
  flex-direction:column;
  gap:10px;
}
@media (max-width: 520px){
  .toastHost{ left: 12px; right: 12px; bottom: 12px; }
}
.toast{
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(18,18,22,.94);
  box-shadow: 0 18px 60px rgba(0,0,0,.35), 0 0 0 1px rgba(255,255,255,.14);
  padding: 12px 12px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  transform: translateY(10px);
  opacity:0;
  animation: toastIn .18s var(--easeOut) forwards;
}
@keyframes toastIn{ to{ transform: translateY(0); opacity:1; } }
.toast .t{ font-weight: 950; font-size: 13px; }
.toast .s{ color: rgba(255,255,255,.72); font-weight: 800; font-size: 12px; margin-top: 2px; }
.toast .actions{ display:flex; gap:8px; }
.toast .btn{
  border:none;
  border-radius: 12px;
  padding: 9px 10px;
  background: rgba(255,255,255,.08);
  color: rgba(255,255,255,.92);
  font-weight: 950;
  cursor:pointer;
}
.toast .btn.red{ background: rgba(255,255,255,.18); }
.toastOut{ animation: toastOut .16s var(--easeOut) forwards; }
@keyframes toastOut{ to{ transform: translateY(10px); opacity:0; } }
/* ===== Drag handle + dragging ===== */
.dragHandle{
  width: 38px;
  height: 38px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  display:grid;
  place-items:center;
  font-size: 16px;
  line-height: 1;
  cursor: grab;
  user-select:none;
  -webkit-user-select:none;
  touch-action:none;
  transition: background .16s ease, border-color .16s ease, transform .16s ease;
}
.dragHandle:hover{
  background: rgba(255,255,255,.10);
  border-color: rgba(255,255,255,.14);
  transform: translateY(-1px);
}
.dragHandle:active{ cursor: grabbing; transform: translateY(0) scale(.99); }

details.item.dragging{
  opacity: .78;
}
details.item.dragging .dragHandle{
  cursor: grabbing;
}

/* ===== Drag sorting: no-flicker mode + placeholder ===== */
body.dragMode{ user-select:none; -webkit-user-select:none; }
body.dragMode details.item{
  transition: none !important;
  animation: none !important;
}
body.dragMode details.item:hover{
  transform: none !important;
  box-shadow: none !important;
}
body.dragMode details.item summary:hover .arrow{ background: rgba(255,255,255,.06); }
body.dragMode .itemBody{ transition: none !important; }

/* Ghost card while dragging */
body.dragMode details.item.dragging{
  opacity: .38 !important;
  filter: saturate(.9) blur(.2px);
}

/* Drop placeholder (insertion highlight) */
.dropPlaceholder{
  border: 1px dashed rgba(255,255,255,.40);
  background: rgba(255,255,255,.06);
  border-radius: 18px;
  box-shadow: 0 0 0 1px rgba(255,255,255,.18), 0 10px 26px rgba(255,255,255,.08);
  transition: height .12s ease, box-shadow .12s ease, background .12s ease, border-color .12s ease;
}


/* ===== Cinema Night mode ===== */
body.cinemaNight{
  background: #060607;
}

body.cinemaNight::after{
  content:"";
  position: fixed;
  inset: 0;
  pointer-events:none;
  z-index: 2;
  background:
    radial-gradient(120% 90% at 50% 45%, rgba(0,0,0,0) 35%, rgba(0,0,0,.58) 100%),
    radial-gradient(90% 60% at 50% 0%, rgba(255,255,255,.12), rgba(0,0,0,0) 60%);
  mix-blend-mode: multiply;
  opacity: .78;
}

body.cinemaNight .topbar{
  background: rgba(0,0,0,.86);
}



/* ===== Profile: open in rated icon ===== */
.favScoreRow{
  display:flex;
  align-items:center;
  gap: 6px;
}
.openRatedIcon{
  width: 26px;
  height: 26px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: rgba(255,255,255,.92);
  display:grid;
  place-items:center;
  cursor:pointer;
  padding:0;
  font-size: 12px;
  font-weight: 1000;
  line-height: 1;
  transition: background .15s ease, transform .15s ease, border-color .15s ease;
}
.openRatedIcon:hover{
  background: rgba(255,255,255,.18);
  border-color: rgba(255,255,255,.45);
  transform: scale(1.06);
}
.openRatedIcon:active{ transform: scale(.95); }




/* ===== Profile: unified button grid + hover reveal ===== */

/* Make profile action rows a consistent grid */
.profilePage .favCard .btns{
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: max-content;
  gap: 8px;
  align-items: center;
  justify-content: flex-start;

  margin-top: 6px;
}

/* Normalize profile buttons inside fav cards */
.profilePage .favCard .btns button{
  height: 32px;
  padding: 0 12px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 950;
  line-height: 32px;
}

/* Make "Сменить" not look like a huge CTA */
.profilePage .favCard .btns button:not(.primary){
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(255,255,255,.12);
  color: rgba(255,255,255,.92);
}

/* Keep score row tidy (rating + icon) */
.profilePage .favScoreRow{
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

/* Hover reveal: hide secondary controls until hover/focus (desktop) */
@media (hover:hover) and (pointer:fine){
  .profilePage .favCard .btns,
  .profilePage .favCard .openRatedIcon{
    opacity: 0;
    transform: translateY(6px);
    pointer-events: none;
    transition: opacity .16s ease, transform .16s ease, filter .16s ease;
    filter: blur(1.5px);
  }

  .profilePage .favCard:hover .btns,
  .profilePage .favCard:focus-within .btns,
  .profilePage .favCard:hover .openRatedIcon,
  .profilePage .favCard:focus-within .openRatedIcon{
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
    filter: blur(0);
  }
}

/* Touch devices: always show controls */
@media (hover:none){
  .profilePage .favCard .btns,
  .profilePage .favCard .openRatedIcon{
    opacity: 1;
    transform: none;
    pointer-events: auto;
    filter: none;
  }
}


  mark{ background: rgba(255,255,255,0.18); color: #fff; padding: 0 4px; border-radius: 6px; box-shadow: 0 0 0 1px rgba(255,255,255,0.35); font-weight: 900; }

/* --- Card hierarchy upgrades (score anchor, clickable tags, notes clamp) --- */
.tagLinks{ display:flex; flex-wrap:wrap; gap:8px; }
.tagLink{
  appearance:none;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  color: rgba(255,255,255,.92);
  padding:6px 10px;
  border-radius:999px;
  font: inherit;
  cursor:pointer;
  transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease, background .15s ease;
}
.tagLink:hover{
  border-color: rgba(255,255,255,.45);
  background: rgba(255,255,255,.12);
  box-shadow: 0 0 0 1px rgba(255,255,255,.25);
  transform: translateY(-1px);
}
.tagLink:active{ transform: translateY(0px) scale(.98); }

.notesText{ white-space: pre-wrap; }
.notesClamp{
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
.notesExpanded{
  display:block;
  overflow: visible;
  -webkit-line-clamp: unset;
}
.notesToggle{
  margin-top:8px;
  padding:6px 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  color: rgba(255,255,255,.9);
  cursor:pointer;
  transition: background .15s ease, border-color .15s ease, transform .15s ease;
}
.notesToggle:hover{
  border-color: rgba(255,255,255,.22);
  background: rgba(255,255,255,.09);
}
.notesToggle:active{ transform: scale(.99); }


/* --- Profile personalization --- */
.fieldRow{display:flex;flex-direction:column;gap:6px;margin-top:10px;}
.fieldRow input{width:100%;}
.genreChip.isPick{cursor:pointer; user-select:none;}
.genreChip.isPick:hover{filter:brightness(1.08);}
.genreChip.isPick.on{
  box-shadow: 0 0 0 1px rgba(255,255,255,0.55), 0 10px 20px rgba(255,255,255,0.15);
  background: rgba(255,255,255,0.16);
}

/* ===== Now Watching (Смотрю сейчас) ===== */
.progressBar{
  height: 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.08);
  overflow:hidden;
}
.progressBar > div{
  height:100%;
  width:0%;
  background: rgba(255,255,255,.88);
  border-radius: 999px;
  transition: width .18s ease;
}
.nowWidget{
  margin-top: 14px;
  display:flex;
  gap: 12px;
  align-items:stretch;
  flex-wrap:wrap;
}
.nowWidgetMain{
  flex:1;
  min-width: 260px;
  display:flex;
  flex-direction:column;
  gap: 10px;
}
.nowWidgetHead{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap: 10px;
}
.nowTitle{
  margin:0;
  font-size: 14px;
  font-weight: 1000;
}
.nowSub{
  margin-top: 4px;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}
.nowMiniStats{
  margin-top: 8px;
  display:flex;
  flex-direction:column;
  gap: 4px;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}
.nowMiniStats b{
  color: var(--text);
  font-weight: 900;
}
.episodeGrid{
  margin-top: 12px;
  display:flex;
  flex-direction:column;
  gap: 10px;
}
.seasonBlock{
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  border-radius: 16px;
  overflow:hidden;
}
.seasonHead{
  padding: 10px 12px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  cursor:pointer;
  user-select:none;
}
.seasonHead b{ font-weight: 1000; }
.seasonBody{
  border-top: 1px solid rgba(255,255,255,.06);
  padding: 10px 12px 12px;
  display:none;
}
.seasonBlock.open .seasonBody{ display:block; }
.epRow{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap: 10px;
  padding: 8px 10px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  border-radius: 14px;
}
.epRow + .epRow{ margin-top: 8px; }
.epLeft{ display:flex; gap: 10px; align-items:flex-start; min-width:0; }
.epLeft input{ margin-top: 2px; accent-color: var(--accent); }
.epMeta{ min-width:0; }
.epTitle{
  margin:0;
  font-size: 13px;
  font-weight: 950;
  line-height: 1.2;
  word-break: break-word;
}
.epSub{
  margin-top: 4px;
  color: var(--muted);
  font-size: 12px;
}
.epBadge{
  flex-shrink:0;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color: rgba(255,255,255,.9);
  border-radius: 999px;
  padding: 4px 10px;
  font-weight: 950;
  font-size: 12px;
  font-variant-numeric: tabular-nums;
}
.sessionRow{
  display:flex;
  gap: 10px;
  flex-wrap:wrap;
  align-items:center;
  justify-content:space-between;
  margin-top: 12px;
}
.sessionPill{
  border: 1px solid rgba(255,255,255,.35);
  background: rgba(255,255,255,.12);
  color: rgba(255,255,255,.92);
  border-radius: 999px;
  padding: 6px 10px;
  font-weight: 950;
  font-size: 12px;
}
.nowEmpty{
  color: var(--muted);
  font-size: 13px;
  padding: 8px 0;
}


/* Next episode banner */
.nextBanner{
  margin-top: 10px;
  border: 1px solid rgba(255,255,255,.35);
  background: rgba(255,255,255,.10);
  color: rgba(255,255,255,.95);
  border-radius: 14px;
  padding: 10px 12px;
  font-weight: 950;
  cursor: pointer;
  user-select: none;
  transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
}
.nextBanner:hover{
  background: rgba(255,255,255,.14);
  box-shadow: 0 10px 22px rgba(255,255,255,.18);
  transform: translateY(-1px);
}
.nextBanner.hidden{ display:none; }

/* Finished prompt + confetti */
.finishPrompt{
  margin-top: 12px;
  border: 1px solid rgba(255,255,255,.25);
  background: linear-gradient(140deg, rgba(255,255,255,.12), rgba(255,255,255,.05));
  border-radius: 16px;
  padding: 12px 14px;
  display:flex;
  flex-direction:column;
  gap: 8px;
  position:relative;
  overflow:hidden;
}
.finishTitle{
  font-weight: 1000;
  font-size: 14px;
}
.finishSubtitle{
  color: var(--muted);
  font-size: 13px;
}
.finishActions{
  display:flex;
  flex-wrap:wrap;
  gap: 8px;
}
.confettiLayer{
  position: fixed;
  inset: 0;
  pointer-events: none;
  overflow: hidden;
  z-index: 200;
  opacity: 0;
  transition: opacity .18s ease;
}
.confettiLayer.show{ opacity: 1; }
.confettiPiece{
  position:absolute;
  width: 8px;
  height: 14px;
  border-radius: 3px;
  opacity: 0;
  animation: confettiFall var(--duration) ease-in var(--delay) forwards;
  transform: translate3d(0,-10vh,0) rotate(0deg);
}
@keyframes confettiFall{
  0%{ transform: translate3d(0,-10vh,0) rotate(0deg); opacity:0; }
  10%{ opacity: 1; }
  100%{ transform: translate3d(var(--drift), 110vh, 0) rotate(360deg); opacity:0; }
}

/* Episode focus highlight */
.epRow.focusNext{
  outline: 2px solid rgba(255,255,255,.85);
  box-shadow: 0 0 0 4px rgba(255,255,255,.18);
  border-radius: 14px;
}


/* =========================
   Monochrome (B/W) theme override
   ========================= */
:root{
  --accent:#ffffff;
  --good:#ffffff;
  --bad:#ffffff;
  --muted:rgba(255,255,255,.68);
  --border:rgba(255,255,255,.14);
  --card:rgba(255,255,255,.06);
  --card2:rgba(255,255,255,.08);
}
html, body{
  background:#000 !important;
  color: var(--text);
}
/* remove red/pink glows everywhere */
.topbar{
  box-shadow: 0 14px 60px rgba(0,0,0,.65);
}
.brandDot, .brandDotMini{
  background:#fff !important;
  box-shadow:none !important;
}
.homeTitle span.red, .homeTitle .red{ color:#fff !important; }

/* buttons */
button.primary, .primary{
  border-color: rgba(255,255,255,.30) !important;
  background: rgba(255,255,255,.10) !important;
  box-shadow:
    0 0 0 1px rgba(255,255,255,.18),
    0 0 18px rgba(255,255,255,.14) !important;
}
button.primary:hover, .primary:hover{
  background: rgba(255,255,255,.14) !important;
  box-shadow:
    0 0 0 1px rgba(255,255,255,.26),
    0 0 26px rgba(255,255,255,.18) !important;
}

button.danger, .danger, .dangerMini{
  border-color: rgba(255,255,255,.22) !important;
  background: rgba(255,255,255,.08) !important;
}
button.danger:hover, .danger:hover, .dangerMini:hover{
  background: rgba(255,255,255,.12) !important;
}

/* pills / badges */
.badgeRed, .tagPill, .valuePill{
  border-color: rgba(255,255,255,.20) !important;
  background: rgba(255,255,255,.10) !important;
  color: rgba(255,255,255,.92) !important;
}
.iconBtn.favOn{
  border-color: rgba(255,255,255,.30) !important;
  background: rgba(255,255,255,.12) !important;
}

/* range accent */
input[type="range"]{ accent-color: #ffffff !important; }

/* toast & overlays */
.toast{
  border: 1px solid rgba(255,255,255,.14) !important;
  background: rgba(12,12,14,.96) !important;
  box-shadow: 0 18px 60px rgba(0,0,0,.55) !important;
}
.toast .btn.red{ background: rgba(255,255,255,.10) !important; }

/* next banner marker line */
.nextBanner{
  border-color: rgba(255,255,255,.14) !important;
  background: rgba(255,255,255,.06) !important;
}
.episodeLine,
.episodeRow{
  --marker: rgba(255,255,255,.85);
}
.epMarker, .episodeMarker{
  background: rgba(255,255,255,.85) !important;
  box-shadow: none !important;
}
/* subtle page background texture */
body::before{
  content:"";
  position:fixed;
  inset:0;
  pointer-events:none;
  background: radial-gradient(900px 500px at 50% 0%, rgba(255,255,255,.06), transparent 60%);
  opacity:1;
  z-index:-1;
}

</style>
</head>
<body>
  <div class="topbar">
    <div class="topbarInner">
      <div class="brandMini"><span class="logoMark" aria-hidden="true"></span>Netfly</div>

      <div class="nav" id="nav"></div>

      <div class="profileWrap">
        <button class="profileBtn" id="profileBtn" type="button" title="Профиль"><svg class="profileIcon" width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
  <path d="M20 21a8 8 0 0 0-16 0" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
  <path d="M12 13a4.5 4.5 0 1 0-4.5-4.5A4.5 4.5 0 0 0 12 13Z" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
</svg></button>
      </div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <!-- HOME -->
    <section id="view-home" class="view">
      <div class="homeCenter">
        <h1 class="homeTitle">Net<span class="red">fly</span></h1>
        <div class="homeSub">Твой личный трекер фильмов и сериалов: оценивай, сохраняй “буду смотреть”, собирай избранное и находи новые идеи.</div>
      </div>

      <div class="card">
        <div class="sectionTitle">Последние оценённые</div>
        <div id="recentWrap"></div>
        <div id="nowWidgetHome"></div>
      </div>
    </section>

    <!-- EVALUATE (full width) -->
    <section id="view-evaluate" class="hidden view">
      <section class="card">
        <label for="movieName">Название фильма / сериала</label>

        <div class="dropdown">
          <div class="nameRow">
            <input id="movieName" type="text" placeholder="Начни печатать (мин. 3 символа)..." maxlength="80" />
            <button id="omdbSearchBtn" type="button">Найти</button>
            <button class="primary" id="addWishBtn" type="button" title="Добавить в 'Буду смотреть' из текущего выбранного OMDb">+ В буду смотреть</button>
          </div>
          <div class="results" id="omdbResults"></div>
          <div class="omdbHint" id="omdbStatus"></div>
        </div>

        <div class="formGrid">
          <div>
            <label for="director">Режиссёр(ы)</label>
            <input id="director" type="text" placeholder="Автозаполнится из OMDb" maxlength="120" />
          </div>
          <div>
            <label for="year">Год</label>
            <input id="year" type="number" placeholder="2014" min="1888" max="2100" />
          </div>
        </div>

        <div class="formGrid2">
          <div>
            <label for="status">Статус</label>
            <select id="status">
              <option value="watched" selected>Оценено</option>
              <option value="wish">Буду смотреть</option>
              <option value="rewatch">Пересматриваю</option>
              <option value="dropped">Бросил</option>
            </select>
          </div>
          <div>
            <label for="tags">Теги (через запятую)</label>
            <input id="tags" type="text" placeholder="sci-fi, драма, пересмотреть" maxlength="160" />
          </div>
        </div>

        <div style="margin-top:10px;">
          <label for="notes">Заметки</label>
          <textarea id="notes" placeholder="Например: сильная концовка, пересмотреть сцену..."></textarea>
        </div>

        <div class="rows" id="sliders"></div>

        <div class="summary">
          <div class="scoreBox">
            <div class="score">
              <div class="k">Итоговая оценка</div>
              <div class="v" id="avgScore">—</div>
            </div>
            <div class="score">
              <div class="k">Сумма (3 шкалы)</div>
              <div class="v" id="sumScore">—</div>
            </div>
          </div>

          <div class="btns">
            <button id="resetBtn" type="button">Сбросить</button>
            <button class="primary" id="addBtn" type="button">Добавить</button>
          </div>
        </div>

        <div class="note">
          Система: 3 шкалы 0–10 — Общее впечатление, Вовлечённость, Эмоции после просмотра. Итог = среднее трёх.
        </div>
      </section>
    </section>

    <!-- RATED (full width) -->
    <section id="view-rated" class="hidden view">
      <section class="card">
        <div class="listHeader">
          <div class="listTop">
            <h2>Оценённые</h2>
            <button class="danger" id="clearAllRatedBtn" type="button">Очистить оценённые</button>
          </div>

          <div class="controls">
            <div>
              <label for="search">Поиск по названию</label>
              <input id="search" type="text" placeholder="Начни вводить..." />
            </div>
            <div>
              <label for="sort">Сортировка</label>
              <select id="sort">
                <option value="new">Сначала новые</option>
                <option value="best">По лучшей оценке</option>
                <option value="emotions">По эмоциям</option>
                <option value="engage">По вовлечённости</option>
                <option value="name">По названию (A→Я)</option>
                <option value="year_desc">По году (новые→старые)</option>
              </select>
            </div>
          </div>

          <div class="filters">
            <div class="filterRow">
              <label for="minAvg">Минимальная оценка</label>
              <select id="minAvg">
                <option value="0" selected>Любая</option>
                <option value="6">≥ 6.0</option>
                <option value="7">≥ 7.0</option>
                <option value="8">≥ 8.0</option>
                <option value="9">≥ 9.0</option>
              </select>
            </div>

            <div class="filterRow">
              <label for="tagFilter">Фильтр по тегу</label>
              <input id="tagFilter" type="text" placeholder="например: драма" />
              <div class="inline">
                <input id="onlyFav" type="checkbox" />
                <label for="onlyFav" style="margin:0; color:var(--muted); font-size:12px;">Только избранное</label>
              </div>
            </div>
          </div>

          <div class="small" id="stats"></div>
        </div>

        <div class="items" id="items"></div>

        <div class="summary" style="margin-top:12px;">
          <div class="small" id="pageInfo"></div>
          <div class="btns">
            <button id="prevPageBtn" type="button">←</button>
            <button id="nextPageBtn" type="button">→</button>
          </div>
        </div>
      </section>
    </section>

        <!-- WISH MOVIES (full width + posters) -->
    <section id="view-wish-movies" class="hidden view">
      <section class="card">
        <div class="listHeader">
          <div class="listTop">
            <h2>Буду смотреть</h2>
            <div class="segmented wishSegment">
              <button type="button" class="segBtn wishKindBtn" data-kind="movie">Фильмы</button>
              <button type="button" class="segBtn wishKindBtn" data-kind="series">Сериалы</button>
            </div>
            <button id="wishMoviesRandomBtn" type="button">Случайный фильм</button>
            <button class="danger" id="clearAllWishMoviesBtn" type="button">Очистить очередь</button>
          </div>

          <div class="controls">
            <div>
              <label for="wishMoviesSearch">Поиск</label>
              <input id="wishMoviesSearch" type="text" placeholder="Начни вводить..." />
            </div>
          </div>

          <div class="small" id="wishMoviesStats"></div>
        </div>

        <div id="wishMoviesList" style="display:flex; flex-direction:column; gap:10px;"></div>
      </section>
    </section>

    <!-- WISH SERIES (full width + posters) -->
    <section id="view-wish-series" class="hidden view">
      <section class="card">
        <div class="listHeader">
          <div class="listTop">
            <h2>Буду смотреть</h2>
            <div class="segmented wishSegment">
              <button type="button" class="segBtn wishKindBtn" data-kind="movie">Фильмы</button>
              <button type="button" class="segBtn wishKindBtn" data-kind="series">Сериалы</button>
            </div>
            <button id="wishSeriesRandomBtn" type="button">Случайный сериал</button>
            <button class="danger" id="clearAllWishSeriesBtn" type="button">Очистить очередь</button>
          </div>

          <div class="controls">
            <div>
              <label for="wishSeriesSearch">Поиск</label>
              <input id="wishSeriesSearch" type="text" placeholder="Начни вводить..." />
            </div>
          </div>

          <div class="small" id="wishSeriesStats"></div>
        </div>

        <div id="wishSeriesList" style="display:flex; flex-direction:column; gap:10px;"></div>
      </section>
    </section>


    <!-- NOW WATCHING (full width) -->
    <section id="view-now" class="hidden view">
      <section class="card">
        <div class="listHeader">
          <div class="listTop">
            <h2>Смотрю сейчас</h2>
            <div class="small" id="nowStatsTop"></div>
          </div>
          <div id="nowNextBanner" class="nextBanner hidden" role="button" tabindex="0"></div>
          <div id="nowFinishedPrompt" class="finishPrompt hidden">
            <div class="finishTitle">Похоже, сериал досмотрен 🎬</div>
            <div class="finishSubtitle">Поздравляем! Отличная работа — весь сезон(ы) позади.</div>
            <div class="finishActions">
              <button class="primary" id="finishToEvaluate" type="button">В “Оценить”</button>
              <button class="ghost" id="finishToRated" type="button">В “Оцененные”</button>
              <button class="ghost" id="finishLater" type="button">Позже</button>
            </div>
          </div>

                    <div class="controls" style="grid-template-columns: 1fr;">
            <div id="nowAddControls">
              <label>Добавить сериал можно только из очереди (“Буду смотреть” → Сериалы)</label>
              <div class="nameRow" style="align-items:center;">
                <button class="primary" id="nowPickFromWishBtn" type="button">Выбрать из очереди</button>
              </div>
              <div class="small" style="margin-top:8px; color:var(--muted);">
                Сериал сначала добавь в “Буду смотреть” (раздел “Сериалы”), а здесь просто выбери его — он станет активным.
              </div>
            </div>

            <div id="nowDeleteControls" class="hidden">
              <label>Активный сериал выбран</label>
              <div class="nameRow" style="align-items:center;">
                <button class="danger" id="nowDeleteActiveBtn" type="button">Удалить сериал</button>
              </div>
              <div class="small" style="margin-top:8px; color:var(--muted);">
                Удаляет активный сериал из “Смотрю сейчас”. Из очереди (“Буду смотреть”) сериал не удаляется.
              </div>
            </div>
          </div>
        </div>

        <div id="nowCard"></div>
      </section>
    </section>


    <!-- TIPS (AI recommendations) -->
    <section id="view-tips" class="hidden view">
      <section class="card">
        <div class="listHeader">
          <div class="listTop">
            <h2>Советы от ИИ</h2>
            <div class="small">Upstage Solar Pro 3 (free)</div>
          </div>
          <div class="small">Получай рекомендации фильмов и сериалов на основе твоей библиотеки.</div>
        </div>

        <div class="tipsGrid">
          <div class="tipsPanel">
            <div class="sectionTitle" style="margin:0;">Подключение</div>
            <ol class="tipsSteps">
              <li>Используем OpenRouter и модель Upstage Solar Pro 3 (free).</li>
              <li>API‑ключ задаётся в коде (константа <code>OPENROUTER_API_KEY</code>).</li>
              <li>Задай запрос: например, “Посоветуй 5 сериалов на вечер”.</li>
            </ol>
            <div class="tipsHint">Ключ не показывается в интерфейсе и не запрашивается у пользователя.</div>
          </div>

          <div class="tipsPanel">
            <div class="sectionTitle" style="margin:0;">Запрос к ИИ</div>
            <div>
              <label for="tipsPrompt">Что нужно?</label>
              <textarea id="tipsPrompt" placeholder="Например: Подбери 7 фильмов с сильным финалом и коротким хронометражем"></textarea>
            </div>
            <div class="btns" style="justify-content:flex-start;">
              <button class="primary" id="tipsSendBtn" type="button">Получить советы</button>
              <button id="tipsClearBtn" type="button">Очистить ответ</button>
            </div>
            <div class="tipsStatus" id="tipsStatus">ИИ использует твою библиотеку (оценённые, очередь, теги) как контекст.</div>
            <div class="tipsOutput" id="tipsOutput">Ответ появится здесь.</div>
          </div>
        </div>
      </section>
    </section>


<!-- PROFILE (full width) -->

    <section id="view-profile" class="hidden view">
      <section class="card profilePage">
        <div class="profileHero">
          <div class="avatarCircle" aria-hidden="true">
            <svg width="26" height="26" viewBox="0 0 24 24" fill="none">
              <path d="M20 21a8 8 0 0 0-16 0" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M12 13a4.5 4.5 0 1 0-4.5-4.5A4.5 4.5 0 0 0 12 13Z" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </div>
          <div>
            <h2 class="profileTitle">Мой профиль</h2>
            <div class="profileSubtitle" id="profileSubtitle">Твоя личная библиотека фильмов и сериалов</div>
          </div>
        </div>

        <div class="profileSection" id="supabaseAuth">
          <div class="secHead">
            <h3>Supabase</h3>
            <div class="small">Регистрация и облако</div>
          </div>
          <div class="small supabaseStatus" id="supabaseStatus">Проверяю статус…</div>

          <div id="supabaseLoggedOut">
            <div class="formGrid2">
              <div>
                <label for="supabaseEmail">Email</label>
                <input id="supabaseEmail" type="email" placeholder="you@email.com" autocomplete="email" />
              </div>
              <div>
                <label for="supabasePassword">Пароль</label>
                <input id="supabasePassword" type="password" placeholder="Минимум 6 символов" autocomplete="new-password" />
              </div>
            </div>
            <div class="btns" style="justify-content:flex-start; margin-top:10px;">
              <button class="primary" id="supabaseRegisterBtn" type="button">Зарегистрироваться</button>
              <button id="supabaseLoginBtn" type="button">Войти</button>
            </div>
            <div class="small" style="margin-top:8px; color:var(--muted);">
              После регистрации Supabase отправит письмо для подтверждения.
            </div>
          </div>

          <div id="supabaseLoggedIn" class="hidden">
            <div class="statRow" style="margin-top:10px;">
              <span>Вход выполнен</span>
              <b id="supabaseUserEmail">—</b>
            </div>
            <div class="btns" style="justify-content:flex-start;">
              <button class="primary" id="supabaseSyncBtn" type="button">Синхронизировать</button>
              <button class="danger" id="supabaseLogoutBtn" type="button">Выйти</button>
            </div>
            <div class="small" style="margin-top:8px; color:var(--muted);">
              Библиотека хранится в облаке и кешируется локально.
            </div>
          </div>
        </div>

        <div class="profileSection" style="margin-top:10px;">
  <div class="secHead">
    <h3>Внешний вид</h3>
    <div class="small">Атмосферный режим</div>
  </div>
  <div class="inline">
    <input id="cinemaNightToggle" type="checkbox" />
    <label for="cinemaNightToggle" style="margin:0; color:var(--muted); font-size:12px;">Киноночь</label>
  </div>
</div>

        <div class="statTiles" id="profileTiles"></div>

        <div class="profileSection" id="profileScores"></div>


        <div class="profileSection" id="profileWatchingWeek"></div>



        <div class="profileSection">
          <div class="secHead">
            <h3>Мой вкус</h3>
            <div class="small">Любимые жанры по твоей библиотеке</div>
          </div>
          <div class="genreChips" id="profileGenreChips"></div>
        </div>

        
        <div class="profileSection">
          <div class="secHead">
            <h3>Персонализация</h3>
            <div class="small">Сделай профиль своим</div>
          </div>

          <div class="fieldRow">
            <label class="small" for="profileTagline">Фраза профиля</label>
            <input id="profileTagline" type="text" maxlength="80" placeholder="Например: Люблю медленные драмы и сильные финалы" />
            <div class="small muted">Покажем её под заголовком профиля.</div>
          </div>

          <div style="margin-top:10px;">
            <div class="small">Любимые жанры вручную (до 2)</div>
            <div class="genreChips" id="profileManualGenreChips"></div>
            <div class="small muted" style="margin-top:6px;">Выбери из жанров, которые есть в твоей библиотеке.</div>
          </div>
        </div>

<div class="favGrid" id="profileFavGrid">
          <div class="favCard" id="favMovieCard"></div>
          <div class="favCard" id="favSeriesCard"></div>
          <div class="favCard" id="favDirectorCard"></div>
          <div class="favCard" id="favActorCard"></div>
        </div>

        <div class="twoCol">
          <div class="profileSection">
            <div class="secHead">
              <h3>Лучшие по оценке</h3>
              <div class="small">Топ‑3</div>
            </div>
            <div class="miniList" id="bestList"></div>
          </div>
          <div class="profileSection">
            <div class="secHead">
              <h3>Недавно оценённые</h3>
              <div class="small">Последние 3</div>
            </div>
            <div class="miniList" id="recentRatedList"></div>
          </div>
        </div>

        <datalist id="directorDatalist"></datalist>
        <datalist id="actorDatalist"></datalist>
      </section>
    </section>

    <!-- Picker modal (local база) -->
  <div class="modal" id="pickerModal" aria-hidden="true">
      <div class="modalBackdrop" id="pickerBackdrop" data-close="1"></div>
      <div class="modalCard" role="dialog" aria-modal="true" aria-label="Выбор из базы">
        <div class="modalHead">
          <div>
            <div class="modalTitle" id="pickerTitle">Выбор</div>
            <div class="small" id="pickerHint"></div>
          </div>
          <button class="iconBtn dangerMini" id="pickerCloseBtn" type="button" title="Закрыть">✕</button>
        </div>

        <label for="pickerSearch">Поиск</label>
        <input id="pickerSearch" type="text" placeholder="Начни вводить..." />

        <div class="modalList" id="pickerList"></div>
      </div>
    </div>


  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // ========= Config =========
    // External endpoints + local storage keys live here so they are easy to update.
    const OMDB_BASE = "https://omdb-proxy.makeenkoroma69.workers.dev/";
    const SUPABASE_URL = "https://etokhzddtlsciikyvezu.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV0b2toemRkdGxzY2lpa3l2ZXp1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg3NjEyMDAsImV4cCI6MjA4NDMzNzIwMH0.zvmcDFI6koHgdw9LIL1MOpsiuoNcFxNA6WJjaijwrwA";
    const SUPABASE_TABLE = "libraries";
    const OPENROUTER_BASE = "https://openrouter.ai/api/v1";
    const OPENROUTER_MODEL = "upstage/solar-pro-3:free";
    const OPENROUTER_API_KEY = "";

    const STORAGE_KEY_V6 = "netfly_movies_v6";
    const PROFILE_KEY_V2 = "netfly_profile_v2";
    const NOW_KEY_V1 = "netfly_now_v1";
    const OMDB_EP_CACHE_V1 = "netfly_omdb_eps_v1";
    const SUPABASE_SYNC_KEY = "netfly_supabase_sync_v1";

    // Navigation tabs (id must match view section ids).
    const VIEWS = [
      { id:"home",     label:"Главная" },
      { id:"evaluate", label:"Оценить" },
      { id:"rated",    label:"Оценённые" },
      { id:"wish",    label:"Буду смотреть" },
      { id:"now",     label:"Смотрю сейчас" },
      { id:"tips",    label:"Советы" },
    ];

    // Human-readable labels for status badges.
    const STATUS_LABEL = {
      watched: "Оценено",
      wish: "Буду смотреть",
      rewatch: "Пересматриваю",
      dropped: "Бросил",
    };

    // 3 sliders (0..10) used for overall score.
    const CRITERIA = [
      { key: "overall",  label: "Общее впечатление" },
      { key: "engage",   label: "Вовлечённость" },
      { key: "emotions", label: "Эмоции после просмотра" }
    ];
    const DEFAULT_SCORES = { overall: 0, engage: 0, emotions: 0 };

    // ========= Elements =========
    // Cache all DOM references in one place to avoid repeated queries.
    const els = {
      nav: document.getElementById("nav"),

      viewHome: document.getElementById("view-home"),
      viewEval: document.getElementById("view-evaluate"),
      viewRated: document.getElementById("view-rated"),
      viewWishMovies: document.getElementById("view-wish-movies"),
      viewWishSeries: document.getElementById("view-wish-series"),
      viewProfile: document.getElementById("view-profile"),
      viewNow: document.getElementById("view-now"),
      viewTips: document.getElementById("view-tips"),


      // profile (dashboard)
      profileBtn: document.getElementById("profileBtn"),
      profileTiles: document.getElementById("profileTiles"),
      profileScores: document.getElementById("profileScores"),
      profileWatchingWeek: document.getElementById("profileWatchingWeek"),
      profileGenreChips: document.getElementById("profileGenreChips"),
      profileManualGenreChips: document.getElementById("profileManualGenreChips"),
      profileTagline: document.getElementById("profileTagline"),
      profileSubtitle: document.getElementById("profileSubtitle"),
      favMovieCard: document.getElementById("favMovieCard"),
      favSeriesCard: document.getElementById("favSeriesCard"),
      favDirectorCard: document.getElementById("favDirectorCard"),
      // Supabase auth
      supabaseEmail: document.getElementById("supabaseEmail"),
      supabasePassword: document.getElementById("supabasePassword"),
      supabaseRegisterBtn: document.getElementById("supabaseRegisterBtn"),
      supabaseLoginBtn: document.getElementById("supabaseLoginBtn"),
      supabaseLogoutBtn: document.getElementById("supabaseLogoutBtn"),
      supabaseSyncBtn: document.getElementById("supabaseSyncBtn"),
      supabaseStatus: document.getElementById("supabaseStatus"),
      supabaseLoggedOut: document.getElementById("supabaseLoggedOut"),
      supabaseLoggedIn: document.getElementById("supabaseLoggedIn"),
      supabaseUserEmail: document.getElementById("supabaseUserEmail"),
      favActorCard: document.getElementById("favActorCard"),
      bestList: document.getElementById("bestList"),
      recentRatedList: document.getElementById("recentRatedList"),
      directorDatalist: document.getElementById("directorDatalist"),
      actorDatalist: document.getElementById("actorDatalist"),

      // tips (AI)
      tipsPrompt: document.getElementById("tipsPrompt"),
      tipsSendBtn: document.getElementById("tipsSendBtn"),
      tipsClearBtn: document.getElementById("tipsClearBtn"),
      tipsStatus: document.getElementById("tipsStatus"),
      tipsOutput: document.getElementById("tipsOutput"),

      // picker modal
      pickerModal: document.getElementById("pickerModal"),
      pickerBackdrop: document.getElementById("pickerBackdrop"),
      pickerCloseBtn: document.getElementById("pickerCloseBtn"),
      pickerTitle: document.getElementById("pickerTitle"),
      pickerHint: document.getElementById("pickerHint"),
      pickerSearch: document.getElementById("pickerSearch"),
      pickerList: document.getElementById("pickerList"),

      // home
      recentWrap: document.getElementById("recentWrap"),

      // evaluate
      sliders: document.getElementById("sliders"),
      avgScore: document.getElementById("avgScore"),
      sumScore: document.getElementById("sumScore"),
      addBtn: document.getElementById("addBtn"),
      addWishBtn: document.getElementById("addWishBtn"),
      resetBtn: document.getElementById("resetBtn"),
      movieName: document.getElementById("movieName"),
      director: document.getElementById("director"),
      year: document.getElementById("year"),
      status: document.getElementById("status"),
      tags: document.getElementById("tags"),
      notes: document.getElementById("notes"),
      omdbSearchBtn: document.getElementById("omdbSearchBtn"),
      omdbResults: document.getElementById("omdbResults"),
      omdbStatus: document.getElementById("omdbStatus"),
      // rated list
      items: document.getElementById("items"),
      stats: document.getElementById("stats"),
      search: document.getElementById("search"),
      sort: document.getElementById("sort"),
      minAvg: document.getElementById("minAvg"),
      tagFilter: document.getElementById("tagFilter"),
      onlyFav: document.getElementById("onlyFav"),
      clearAllRatedBtn: document.getElementById("clearAllRatedBtn"),
      prevPageBtn: document.getElementById("prevPageBtn"),
      nextPageBtn: document.getElementById("nextPageBtn"),
      pageInfo: document.getElementById("pageInfo"),
      // wish
      wishMoviesList: document.getElementById("wishMoviesList"),
      wishSeriesList: document.getElementById("wishSeriesList"),
      wishMoviesSearch: document.getElementById("wishMoviesSearch"),
      wishSeriesSearch: document.getElementById("wishSeriesSearch"),
      wishMoviesStats: document.getElementById("wishMoviesStats"),
      wishSeriesStats: document.getElementById("wishSeriesStats"),
      wishMoviesRandomBtn: document.getElementById("wishMoviesRandomBtn"),
      wishSeriesRandomBtn: document.getElementById("wishSeriesRandomBtn"),
      clearAllWishMoviesBtn: document.getElementById("clearAllWishMoviesBtn"),
      clearAllWishSeriesBtn: document.getElementById("clearAllWishSeriesBtn"),
      // now watching
      nowPick: document.getElementById("nowPick"),
      nowOmdbSearchBtn: document.getElementById("nowOmdbSearchBtn"),
      nowOmdbResults: document.getElementById("nowOmdbResults"),
      nowOmdbStatus: document.getElementById("nowOmdbStatus"),
      nowPickFromWishBtn: document.getElementById("nowPickFromWishBtn"),
      nowAddControls: document.getElementById("nowAddControls"),
      nowDeleteControls: document.getElementById("nowDeleteControls"),
      nowDeleteActiveBtn: document.getElementById("nowDeleteActiveBtn"),
      nowApplyBtn: document.getElementById("nowApplyBtn"),
      nowCard: document.getElementById("nowCard"),
      nowStatsTop: document.getElementById("nowStatsTop"),
      nowWidgetHome: document.getElementById("nowWidgetHome"),

    };

    // ========= State =========
    // App-level state lives here and is updated via render helpers.
    let currentView = "home";
    let wishKindActive = "movie"; // "movie" | "series"

    let movies = loadMovies();
    let profile = loadProfile();
    let nowState = loadNowState();
    let omdbEpCache = loadEpCache();

    // Supabase client + session
    let supabaseClient = null;
    let supabaseUser = null;
    let supabaseSyncTimer = null;

    let supabaseRealtimeChannel = null;



    // pulse helper for ⭐ toggle (prevents multiple pulses at once)
    let lastFavPulseId = null;

    // current slider state keyed by CRITERIA entries
    const current = {};
    CRITERIA.forEach(c => current[c.key] = 0);

    // last fetched OMDb metadata for form (to store on add)
    let omdbMetaDraft = null;

    // Rated pagination
    const PAGE_SIZE = 20;
    let ratedPage = 1;

    // Wish drag/drop
    let dragId = null;
    let dragPlaceholder = null;
    let dragLastPlaceholderBeforeId = null;

    // ========= Helpers =========
    // Pure helpers: formatting, storage, utility conversions.
    const CINEMA_KEY = "netfly_cinema_night";

    // Cinema Night theme helpers (adds a class to body + persists state)
    function applyCinemaNight(on){
      document.body.classList.toggle("cinemaNight", !!on);
    }

    function loadCinemaNight(){
      return localStorage.getItem(CINEMA_KEY) === "1";
    }

    function saveCinemaNight(on){
      localStorage.setItem(CINEMA_KEY, on ? "1" : "0");
    }

    // Basic utility helpers
    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
    function normalize(s){ return String(s ?? "").trim().toLowerCase(); }
 


    function pluralRu(n, one, few, many){
      const mod10 = n % 10;
      const mod100 = n % 100;
      if(mod10 === 1 && mod100 !== 11) return one;
      if(mod10 >= 2 && mod10 <= 4 && (mod100 < 10 || mod100 >= 20)) return few;
      return many;
    }
    function formatSeriesCount(n){ return `${n} ${pluralRu(n, "серия", "серии", "серий")}`; }
    function formatHoursCount(n){ return `${n} ${pluralRu(n, "час", "часа", "часов")}`; }
    function formatWeeksCount(n){ return `${n} ${pluralRu(n, "неделя", "недели", "недель")}`; }


    // Builds link to Kino.pub with best-known title and content type.
    function kinoPubSearchUrl(movie, kind){
      const typeRaw = getTypeOfMovie(movie);
      const kindType = kind === "series" ? "series" : "movie";
      const type = (typeRaw === "series" || kindType === "series") ? "serial" : "movie";

      // берем “оригинальное” название из OMDb, если есть
      const title =
        (movie?.omdb?.title && String(movie.omdb.title).trim()) ||
        (movie?.title && String(movie.title).trim()) ||
        (movie?.name && String(movie.name).trim()) ||
        "";

      if(!title) return "";

      return `https://kino.pub/item/search?type=${encodeURIComponent(type)}&mode=&query=${encodeURIComponent(title)}`;
    }


    // Format how long an item has stayed in the queue for UI chips.
    function formatQueueAge(createdAt){
      const ts = Number(createdAt || Date.now());
      const days = Math.max(0, Math.floor((Date.now() - ts) / 86400000));
      if(days <= 0) return "В очереди: сегодня";
      if(days === 1) return "В очереди: 1 день";
      if(days < 30) return `В очереди: ${days} дн.`;
      const months = Math.floor(days / 30);
      if(months === 1) return "В очереди: 1 месяц";
      if(months < 12) return `В очереди: ${months} мес.`;
      const years = Math.floor(months / 12);
      if(years === 1) return "В очереди: 1 год";
      return `В очереди: ${years} лет`;
    }

    // Mark queue items that are "stale" based on added date.
    function isQueueStale(createdAt){
      const ts = Number(createdAt || Date.now());
      const days = Math.max(0, Math.floor((Date.now() - ts) / 86400000));
      return days >= 90;
    }

    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }


    // Highlight query matches in text (safe HTML). Highlights first match of the whole query.
    function highlightHtml(text, queryNorm){
      const raw = String(text ?? "");
      const q = String(queryNorm ?? "").trim();
      if(!q) return escapeHtml(raw);
      const low = normalize(raw);
      const i = low.indexOf(q);
      if(i < 0) return escapeHtml(raw);
      const before = raw.slice(0, i);
      const hit = raw.slice(i, i + q.length);
      const after = raw.slice(i + q.length);
      return `${escapeHtml(before)}<mark>${escapeHtml(hit)}</mark>${escapeHtml(after)}`;
    }

    // Unified search across name, director, actors, tags, genres.
    function movieMatchesQuery(movie, q){
      if(!q) return true;
      const parts = [];
      parts.push(movie?.name ?? "");
      parts.push(movie?.director ?? "");
      parts.push((movie?.tags || []).join(" "));
      const actors = Array.isArray(movie?.omdb?.actors) ? movie.omdb.actors.join(" ") : "";
      parts.push(actors);
      parts.push(movie?.omdb?.genre ?? "");
      parts.push(movie?.omdb?.writer ?? "");
      parts.push(movie?.omdb?.plot ?? "");
      return normalize(parts.join(" ")).includes(q);
    }


    // Close other opened <details> in the same list (accordion behaviour)
    function closeOtherOpenedDetails(containerEl, keepEl){
      if(!containerEl) return;
      const opened = containerEl.querySelectorAll("details.item[open]");
      opened.forEach(d => { if(d !== keepEl) d.open = false; });
    }

/* ===== Micro feedback: animated removal ===== */
function animateRemoveDetails(detailsEl, done){
  if(!detailsEl){ done && done(); return; }
  try{
    const r = detailsEl.getBoundingClientRect();
    detailsEl.style.height = r.height + "px";
    detailsEl.style.overflow = "hidden";
    detailsEl.style.willChange = "height, opacity, transform";
    detailsEl.classList.add("removing");
    requestAnimationFrame(() => {
      detailsEl.style.height = "0px";
      detailsEl.style.opacity = "0";
      detailsEl.style.transform = "translateY(10px)";
    });
    const finish = () => { done && done(); };
    detailsEl.addEventListener("transitionend", finish, { once:true });
    setTimeout(finish, 260);
  }catch(_e){
    done && done();
  }
}



// автоскролл страницы во время перетаскивания (wish)
    function autoScrollDuringDrag(clientY){
      const zone = 80;
      const maxSpeed = 18;
      let dy = 0;

      if(clientY < zone){
        const t = (zone - clientY) / zone;
        dy = -Math.ceil(maxSpeed * t);
      } else if(clientY > (window.innerHeight - zone)){
        const t = (clientY - (window.innerHeight - zone)) / zone;
        dy = Math.ceil(maxSpeed * t);
      }

      if(dy !== 0){
        window.scrollBy({ top: dy, behavior: "auto" });
      }
    }

    function updateWishOrderPillsInDOM(listEl){
      const items = Array.from(listEl.querySelectorAll("details.item"));
      let n = 1;
      for(const el of items){
        const pill = el.querySelector(".orderPill");
        if(pill) pill.textContent = "№" + (n++);
      }
    }

// ========= Toasts =========
    function toast(title, subtitle = "", opts = {}){
      const host = document.getElementById("toastHost");
      if(!host) return;

      const el = document.createElement("div");
      el.className = "toast";
      el.innerHTML = `
        <div>
          <div class="t">${escapeHtml(title)}</div>
          ${subtitle ? `<div class="s">${escapeHtml(subtitle)}</div>` : ``}
        </div>
        <div class="actions"></div>
      `;

      const actions = el.querySelector(".actions");
      const ttl = opts.ttl ?? 2200;

      if(opts.actionText){
        const b = document.createElement("button");
        b.className = "btn" + (opts.actionRed ? " red" : "");
        b.textContent = opts.actionText;
        b.onclick = () => { try{ opts.onAction?.(); } finally { dismiss(); } };
        actions.appendChild(b);
      }

      host.appendChild(el);

      let timer = setTimeout(dismiss, ttl);
      el.onmouseenter = () => { clearTimeout(timer); };
      el.onmouseleave = () => { timer = setTimeout(dismiss, 900); };

      function dismiss(){
        el.classList.add("toastOut");
        setTimeout(() => el.remove(), 180);
      }
    }

    let confettiActive = false;
    function launchConfetti(){
      const layer = document.getElementById("confettiLayer");
      if(!layer || confettiActive) return;
      confettiActive = true;
      layer.innerHTML = "";
      layer.classList.add("show");

      const colors = ["#ffffff", "#f0f0f0", "#d7d7d7", "#bdbdbd"];
      const pieces = 70;
      let maxDuration = 0;

      for(let i = 0; i < pieces; i += 1){
        const piece = document.createElement("span");
        piece.className = "confettiPiece";
        const size = Math.random() * 6 + 6;
        const delay = Math.random() * 0.8;
        const duration = Math.random() * 1.8 + 2.4;
        maxDuration = Math.max(maxDuration, delay + duration);

        piece.style.width = `${size}px`;
        piece.style.height = `${size * 1.6}px`;
        piece.style.left = `${Math.random() * 100}%`;
        piece.style.background = colors[i % colors.length];
        piece.style.setProperty("--delay", `${delay}s`);
        piece.style.setProperty("--duration", `${duration}s`);
        piece.style.setProperty("--drift", `${(Math.random() * 2 - 1) * 20}vw`);
        piece.style.transform = `translate3d(0,-10vh,0) rotate(${Math.random() * 360}deg)`;
        layer.appendChild(piece);
      }

      window.clearTimeout(launchConfetti._t);
      launchConfetti._t = window.setTimeout(() => {
        layer.classList.remove("show");
        layer.innerHTML = "";
        confettiActive = false;
      }, (maxDuration * 1000) + 300);
    }
function format1(n){ return (Math.round(Number(n) * 10) / 10).toFixed(1); }

    // 1 digit after dot + never show > 10
    function formatFinalScore(x){
      const n = Number(x);
      if(!Number.isFinite(n)) return "—";
      return Math.min(n, 10).toFixed(1);
    }

    function parseTags(raw){
      const parts = String(raw ?? "")
        .split(",")
        .map(t => t.trim())
        .filter(Boolean);
      const seen = new Set();
      const out = [];
      for(const t of parts){
        const key = normalize(t);
        if(!key) continue;
        if(seen.has(key)) continue;
        seen.add(key);
        out.push(t);
      }

      return out;
    }

    function typeLabel(t){
      const tt = String(t || "").toLowerCase();
      if(tt === "series" || tt === "tv-series") return "Сериал";
      if(tt === "movie") return "Фильм";
      return tt ? tt : "—";
    }

    // IMPORTANT: simple average of 3 numbers (no coefficients)
    function computeScores(obj){
      const overall  = clamp(Number(obj?.overall  ?? 0), 0, 10);
      const engage   = clamp(Number(obj?.engage   ?? 0), 0, 10);
      const emotions = clamp(Number(obj?.emotions ?? 0), 0, 10);
      const sum = overall + engage + emotions;
      const final = sum / 3;
      return { final, sum, overall, engage, emotions };
    }

    function makeId(){
      return (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()) + "_" + Math.random().toString(16).slice(2));
    }

    // ========= Storage =========
    function saveMovies(){
      localStorage.setItem(STORAGE_KEY_V6, JSON.stringify(movies));
      scheduleSupabaseSync();
    }
    function safeRead(key){
      try{
        const raw = localStorage.getItem(key);
        if(!raw) return null;
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : null;
      }catch{
        return null;
      }
    }
    function loadMovies(){
      const v = safeRead(STORAGE_KEY_V6);
      return v ? v : [];
    }

    function safeReadObj(key){
      try{
        const raw = localStorage.getItem(key);
        if(!raw) return null;
        const parsed = JSON.parse(raw);
        return (parsed && typeof parsed === "object") ? parsed : null;
      }catch{
        return null;
      }
    }

    
function loadProfile(){
      const legacy = safeReadObj("netfly_profile_v1") || {};
      const p = safeReadObj(PROFILE_KEY_V2) || {};
      const src = Object.keys(p).length ? p : legacy;

      // Migration helpers: old version stored names instead of IDs
      function findRatedByName(name){
        const nn = normalize(name);
        if(!nn) return null;
        const rated = movies.filter(m => (m.status || "watched") === "watched");
        return rated.find(m => normalize(m.name) === nn) || null;
      }

      const out = {
        favDirectorName: String(src.favDirectorName || src.favDirector || ""),
        favActorName: String(src.favActorName || src.favActor || ""),
        favMovieId: src.favMovieId || null,
        favSeriesId: src.favSeriesId || null,
      };

      // if IDs missing, try map from legacy names
      if(!out.favMovieId && src.favMovie){
        const m = findRatedByName(src.favMovie);
        if(m) out.favMovieId = m.id;
      }
      if(!out.favSeriesId && src.favSeries){
        const m = findRatedByName(src.favSeries);
        if(m) out.favSeriesId = m.id;
      }

      out.tagline = String(src.tagline || "");
      out.manualGenres = Array.isArray(src.manualGenres) ? src.manualGenres.filter(Boolean).slice(0,2) : [];

      return out;
    }

    function saveProfile(p){
      localStorage.setItem(PROFILE_KEY_V2, JSON.stringify(p));
      scheduleSupabaseSync();
    }
    // ========= Now Watching storage =========
    function loadNowState(){
      const p = safeReadObj(NOW_KEY_V1) || {};
      return {
        imdbID: p.imdbID || null,
        title: p.title || "",
        posterUrl: p.posterUrl || null,
        sourceMovieId: p.sourceMovieId || null,
        finishPromptedFor: p.finishPromptedFor || null,
        finishDismissedFor: p.finishDismissedFor || null,
        startedAt: Number.isFinite(Number(p.startedAt)) ? Number(p.startedAt) : null,
        runtimeMin: Number.isFinite(Number(p.runtimeMin)) ? Number(p.runtimeMin) : null,
        totalSeasons: Number.isFinite(Number(p.totalSeasons)) ? Number(p.totalSeasons) : null,
        // watched: { "S1E1": true, ... }
        watched: (p.watched && typeof p.watched === "object") ? p.watched : {},
        // watchLog: [{ ts, eps, minutes }] (used for last-7-days stats / weekly goal)
        watchLog: Array.isArray(p.watchLog) ? p.watchLog : (
          Array.isArray(p.sessions) ? p.sessions.map(s => ({
            ts: Number(s.tsEnd || s.tsStart || 0) || 0,
            eps: Number(s.eps || 0) || 0,
            minutes: Number(s.minutes || 0) || 0
          })).filter(x => x.ts) : []
        ),
        // activity days for streak: ["YYYY-MM-DD", ...] (unique)
        activityDays: Array.isArray(p.activityDays) ? p.activityDays : [],
        // optional: streak enabled
        streakOn: (p.streakOn ?? true) ? true : false,
        // weekly goal episodes (0 = off)
        goalEps: Number.isFinite(Number(p.goalEps)) ? Number(p.goalEps) : 0,
      };
    }
    function saveNowState(){
      localStorage.setItem(NOW_KEY_V1, JSON.stringify(nowState));
      scheduleSupabaseSync();
    }

    function loadEpCache(){
      const p = safeReadObj(OMDB_EP_CACHE_V1) || {};
      return (p && typeof p === "object") ? p : {};
    }
    function saveEpCache(){
      localStorage.setItem(OMDB_EP_CACHE_V1, JSON.stringify(omdbEpCache));
      scheduleSupabaseSync();
    }

    function getSupabaseSyncAt(){
      return Number(localStorage.getItem(SUPABASE_SYNC_KEY) || 0) || 0;
    }
    function setSupabaseSyncAt(ts){
      localStorage.setItem(SUPABASE_SYNC_KEY, String(ts || Date.now()));
    }

    function setSupabaseStatus(text, isError = false){
      if(!els.supabaseStatus) return;
      els.supabaseStatus.textContent = text;
      els.supabaseStatus.classList.toggle("error", !!isError);
    }

    function updateSupabaseUi(){
      if(!els.supabaseLoggedOut || !els.supabaseLoggedIn) return;
      const loggedIn = !!supabaseUser;
      els.supabaseLoggedOut.classList.toggle("hidden", loggedIn);
      els.supabaseLoggedIn.classList.toggle("hidden", !loggedIn);
      if(els.supabaseUserEmail){
        els.supabaseUserEmail.textContent = loggedIn ? (supabaseUser.email || "Без email") : "—";
      }
      if(!supabaseClient){
        setSupabaseStatus("Supabase не подключён", true);
        return;
      }
      if(loggedIn){
        setSupabaseStatus("Подключено и готово");
      }else{
        setSupabaseStatus("Войдите или зарегистрируйтесь, чтобы включить облако");
      }
    }

    function getLibraryPayload(){
      return {
        movies,
        profile,
        nowState,
        omdbEpCache
      };
    }

    function applyLibraryPayload(payload){
      if(payload && typeof payload === "object"){
        if(Array.isArray(payload.movies)) movies = payload.movies;
        if(payload.profile && typeof payload.profile === "object") profile = payload.profile;
        if(payload.nowState && typeof payload.nowState === "object") nowState = payload.nowState;
        if(payload.omdbEpCache && typeof payload.omdbEpCache === "object") omdbEpCache = payload.omdbEpCache;
      }
      saveMovies();
      saveProfile(profile);
      saveNowState();
      saveEpCache();
      renderEverything();
    }

    async function pullLibraryFromSupabase(reason = "sync"){
      if(!supabaseClient || !supabaseUser) return;
      setSupabaseStatus("Загружаю библиотеку…");
      const { data, error } = await supabaseClient
        .from(SUPABASE_TABLE)
        .select("payload, updated_at")
        .eq("user_id", supabaseUser.id)
        .maybeSingle();

      if(error){
        const msg = String(error.message || "Не удалось загрузить библиотеку.");
        const hint = String(error.details || error.hint || "");
        let help = "Проверь таблицу libraries и RLS.";
        const merged = (msg + " " + hint).toLowerCase();
        if(merged.includes("does not exist") || merged.includes("relation")){
          help = "Проверь, что таблица libraries создана.";
        }else if(merged.includes("permission") || merged.includes("rls")){
          help = "Проверь политики RLS для таблицы libraries.";
        }
        setSupabaseStatus(`Ошибка загрузки: ${msg}`, true);
        toast("Supabase", `${msg} ${help}`.trim());
        return;
      }

      if(!data?.payload){
        if(movies.length || Object.keys(profile || {}).length){
          await pushLibraryToSupabase("seed");
          setSupabaseStatus("Облако пустое — загрузил локальные данные");
        }else{
          setSupabaseStatus("Облако пустое");
        }
        return;
      }

      const remoteUpdatedAt = data.updated_at ? new Date(data.updated_at).getTime() : 0;
      const localUpdatedAt = getSupabaseSyncAt();
      if(localUpdatedAt && remoteUpdatedAt && localUpdatedAt > remoteUpdatedAt){
        await pushLibraryToSupabase("local-newer");
        return;
      }

      applyLibraryPayload(data.payload);
      setSupabaseSyncAt(Date.now());
      setSupabaseStatus(reason === "manual" ? "Синхронизировано" : "Обновлено из облака");
    }

    async function pushLibraryToSupabase(reason = "autosync"){
      if(!supabaseClient || !supabaseUser) return;
      setSupabaseStatus("Сохраняю в облако…");
      const payload = getLibraryPayload();
      const { error } = await supabaseClient
        .from(SUPABASE_TABLE)
        .upsert({
          user_id: supabaseUser.id,
          payload,
          updated_at: new Date().toISOString()
        }, { onConflict: "user_id" });

      if(error){
        const msg = String(error.message || "Не удалось сохранить библиотеку.");
        const hint = String(error.details || error.hint || "");
        let help = "Проверь таблицу libraries и RLS.";
        const merged = (msg + " " + hint).toLowerCase();
        if(merged.includes("does not exist") || merged.includes("relation")){
          help = "Проверь, что таблица libraries создана.";
        }else if(merged.includes("permission") || merged.includes("rls")){
          help = "Проверь политики RLS для таблицы libraries.";
        }
        setSupabaseStatus(`Ошибка сохранения: ${msg}`, true);
        if(reason !== "autosync") toast("Supabase", `${msg} ${help}`.trim());
        return;
      }
      setSupabaseSyncAt(Date.now());
      setSupabaseStatus(reason === "manual" ? "Сохранено в облако" : "Сохранено");
    }

    function scheduleSupabaseSync(){
      if(!supabaseClient || !supabaseUser) return;
      window.clearTimeout(supabaseSyncTimer);
      supabaseSyncTimer = window.setTimeout(() => {
        pushLibraryToSupabase("autosync");
      }, 900);
    }


    function subscribeSupabaseRealtime(){
      if(!supabaseClient || !supabaseUser) return;
      if(supabaseRealtimeChannel){
        supabaseClient.removeChannel(supabaseRealtimeChannel);
        supabaseRealtimeChannel = null;
      }
      supabaseRealtimeChannel = supabaseClient
        .channel(`libraries:${supabaseUser.id}`)
        .on(
          "postgres_changes",
          {
            event: "*",
            schema: "public",
            table: SUPABASE_TABLE,
            filter: `user_id=eq.${supabaseUser.id}`
          },
          async (payload) => {
            const remoteUpdated = payload?.new?.updated_at
              ? new Date(payload.new.updated_at).getTime()
              : 0;
            const localUpdated = getSupabaseSyncAt();
            if(remoteUpdated && localUpdated && remoteUpdated <= localUpdated) return;
            if(payload?.new?.payload){
              applyLibraryPayload(payload.new.payload);
              setSupabaseSyncAt(Date.now());
              setSupabaseStatus("Обновлено в реальном времени");
              return;
            }
            await pullLibraryFromSupabase("realtime");
          }
        )
        .subscribe();
    }



    async function initSupabase(){
      if(!window.supabase || !SUPABASE_URL || !SUPABASE_ANON_KEY){
        updateSupabaseUi();
        return;
      }
      supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      const { data } = await supabaseClient.auth.getSession();
      supabaseUser = data?.session?.user || null;
      updateSupabaseUi();

      if(supabaseUser){
        await pullLibraryFromSupabase("init");
        subscribeSupabaseRealtime();
      }

      if(supabaseUser) await pullLibraryFromSupabase("init");


      supabaseClient.auth.onAuthStateChange(async (_event, session) => {
        supabaseUser = session?.user || null;
        updateSupabaseUi();
        if(supabaseUser){
          await pullLibraryFromSupabase("auth");

          subscribeSupabaseRealtime();
        }else if(supabaseRealtimeChannel){
          supabaseClient.removeChannel(supabaseRealtimeChannel);
          supabaseRealtimeChannel = null;


        }
      });
    }

    function parseRuntimeMinutes(runtimeStr){
      // "45 min" or "1 h 2 min" or "N/A"
      const s = String(runtimeStr || "");
      const m = s.match(/(\d+)\s*min/i);
      if(m) return clamp(Number(m[1]), 1, 400);
      const h = s.match(/(\d+)\s*h/i);
      const mm = s.match(/h\s*(\d+)\s*min/i);
      if(h){
        const hh = clamp(Number(h[1]), 0, 20);
        const mins = mm ? clamp(Number(mm[1]), 0, 59) : 0;
        const total = hh*60 + mins;
        return total ? clamp(total, 1, 400) : null;
      }
      return null;
    }

    function ymd(d){
      const dt = d instanceof Date ? d : new Date(d);
      const y = dt.getFullYear();
      const m = String(dt.getMonth()+1).padStart(2,"0");
      const dd = String(dt.getDate()).padStart(2,"0");
      return `${y}-${m}-${dd}`;
    }

    function getNowWatchedCount(){
      return Object.values(nowState.watched || {}).filter(Boolean).length;
    }

    function getNowTotalCount(){
      // Use cache if available
      if(!nowState.imdbID) return null;
      const entry = omdbEpCache[nowState.imdbID];
      if(entry && entry.totalEpisodes) return Number(entry.totalEpisodes) || null;
      return null;
    }

    function computeNowProgress(){
      const watched = getNowWatchedCount();
      const total = getNowTotalCount();
      const pct = total ? Math.round((watched/total)*100) : null;
      return { watched, total, pct };
    }

    function getNextUnwatched(){
      if(!nowState.imdbID) return null;
      const entry = omdbEpCache[nowState.imdbID];
      if(!entry || !entry.seasons) return null;
      const seasons = Object.keys(entry.seasons).map(n=>Number(n)).filter(n=>n>0).sort((a,b)=>a-b);
      for(const s of seasons){
        const eps = entry.seasons[String(s)] || [];
        for(const ep of eps){
          const key = `S${s}E${ep.Episode}`;
          if(!nowState.watched[key]) return { season: s, episode: Number(ep.Episode), title: ep.Title || "" };
        }
      }
      return null;
    }

    function markActivityToday(){
      const day = ymd(Date.now());
      if(!nowState.activityDays.includes(day)){
        nowState.activityDays.push(day);
        nowState.activityDays.sort();
      }
    }


    function recordWatch(eps = 1){
      const e = clamp(Number(eps || 1) || 1, 1, 999);
      const minPer = Number(nowState.runtimeMin || 0) || 0;
      const minutes = minPer ? (e * minPer) : 0;

      nowState.watchLog = Array.isArray(nowState.watchLog) ? nowState.watchLog : [];
      nowState.watchLog.unshift({ ts: Date.now(), eps: e, minutes });
      nowState.watchLog = nowState.watchLog.slice(0, 500);
    }

    function computeStreak(){
      if(!nowState.streakOn) return 0;
      const days = (nowState.activityDays || []).slice().sort();
      if(!days.length) return 0;
      // count consecutive ending today
      const today = ymd(Date.now());
      let streak = 0;
      let cur = today;
      const set = new Set(days);
      while(set.has(cur)){
        streak += 1;
        const dt = new Date(cur + "T00:00:00");
        dt.setDate(dt.getDate()-1);
        cur = ymd(dt);
      }
      return streak;
    }

    function computeWeeksWatching(){
      const activity = Array.isArray(nowState.activityDays) ? nowState.activityDays.filter(Boolean) : [];
      let startTs = null;
      if(activity.length){
        const first = activity.slice().sort()[0];
        startTs = new Date(first + "T00:00:00").getTime();
      }else if(Array.isArray(nowState.watchLog) && nowState.watchLog.length){
        const times = nowState.watchLog.map(it => Number(it.ts || 0)).filter(Boolean).sort((a,b)=>a-b);
        startTs = times[0] || null;

      }else if(Number.isFinite(Number(nowState.startedAt))){
        startTs = Number(nowState.startedAt);


      }
      if(!startTs) return null;
      const days = Math.max(1, Math.floor((Date.now() - startTs) / 86400000) + 1);
      return Math.max(1, Math.ceil(days / 7));
    }

    function buildNowMiniStatsHtml(watched, total){
      const remaining = total === null ? null : Math.max(total - watched, 0);
      const remainingHours = remaining !== null && nowState.runtimeMin ? Math.round((remaining * nowState.runtimeMin) / 60) : null;
      const weeksWatching = computeWeeksWatching();
      const miniStats = [];
      if(remaining !== null) miniStats.push(`🕒 Осталось: <b>${formatSeriesCount(remaining)}</b>`);
      if(remainingHours !== null) miniStats.push(`⏱ ≈ ${formatHoursCount(remainingHours)}`);
      if(weeksWatching !== null) miniStats.push(`📅 Смотришь ${formatWeeksCount(weeksWatching)}`);
      return miniStats.length
        ? `<div class="nowMiniStats">${miniStats.map(line => `<div>${line}</div>`).join("")}</div>`
        : "";
    }

    function sumMinutesLast7Days(){
      const now = Date.now();
      const from = now - 7*86400000;
      const log = Array.isArray(nowState.watchLog) ? nowState.watchLog : [];
      let eps = 0, min = 0;
      for(const it of log){
        const ts = Number(it.ts || 0);
        if(ts >= from){
          eps += Number(it.eps || 0);
          min += Number(it.minutes || 0);
        }
      }
      return { eps, minutes: min };
    }




    // ========= Navigation =========
    function renderNav(){
      els.nav.innerHTML = "";
      VIEWS.forEach(v => {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "navBtn" + (currentView === v.id ? " active" : "");
        b.textContent = v.label;
        b.addEventListener("click", () => goTo(v.id));
        els.nav.appendChild(b);
      });
    }

    function goTo(viewId, opts = {}){
      currentView = viewId;

      els.viewHome.classList.toggle("hidden", viewId !== "home");
      els.viewEval.classList.toggle("hidden", viewId !== "evaluate");
      els.viewRated.classList.toggle("hidden", viewId !== "rated");
      if(els.viewNow) els.viewNow.classList.toggle("hidden", viewId !== "now");
      if(els.viewTips) els.viewTips.classList.toggle("hidden", viewId !== "tips");
      if(viewId === "wish"){
        els.viewWishMovies.classList.toggle("hidden", wishKindActive !== "movie");
        els.viewWishSeries.classList.toggle("hidden", wishKindActive !== "series");
      } else {
        els.viewWishMovies.classList.add("hidden");
        els.viewWishSeries.classList.add("hidden");
      }
      els.viewProfile.classList.toggle("hidden", viewId !== "profile");

      els.profileBtn.classList.toggle("active", viewId === "profile");

      renderNav();

      if(viewId === "home") renderHome();
      if(viewId === "rated"){
        renderRated();
        if(opts.openId) openRatedItem(opts.openId);
      }
      if(viewId === "wish") renderWish();
      if(viewId === "now") renderNow();
      if(viewId === "tips") renderTips();
      if(viewId === "profile") renderProfile();
    }
    
    
    // ========= Wish view (single tab with internal switch) =========
    function syncWishToggleButtons(){
      document.querySelectorAll(".wishKindBtn").forEach(btn => {
        const k = btn.getAttribute("data-kind");
        btn.classList.toggle("active", k === wishKindActive);
      });
    }

    function setWishKind(kind){
      const k = (kind === "series") ? "series" : "movie";
      wishKindActive = k;
      syncWishToggleButtons();
      if(currentView === "wish"){
        els.viewWishMovies.classList.toggle("hidden", wishKindActive !== "movie");
        els.viewWishSeries.classList.toggle("hidden", wishKindActive !== "series");
        renderWish();
      }
    }

    function renderWish(){
      syncWishToggleButtons();
      if(wishKindActive === "series") renderWishSeries();
      else renderWishMovies();
    }

    document.addEventListener("click", (e) => {
      const btn = e.target.closest?.(".wishKindBtn");
      if(!btn) return;
      e.preventDefault();
      setWishKind(btn.getAttribute("data-kind"));
    });

// ========= Tips (AI) =========
    function getTopTags(limit = 6){
      const counts = new Map();
      getRated().forEach(movie => {
        const tags = Array.isArray(movie.tags) ? movie.tags : [];
        tags.forEach(tag => {
          const t = String(tag || "").trim();
          if(!t) return;
          counts.set(t, (counts.get(t) || 0) + 1);
        });
      });
      return Array.from(counts.entries())
        .sort((a,b) => b[1] - a[1])
        .slice(0, limit)
        .map(([tag]) => tag);
    }

    function buildTipsPrompt(userPrompt){
      const rated = getRated();
      const wish = movies.filter(m => (m.status || "watched") === "wish");
      const topTags = getTopTags();
      const recentRated = rated
        .slice()
        .sort((a,b) => (b.createdAt || 0) - (a.createdAt || 0))
        .slice(0, 6)
        .map(m => m.name)
        .filter(Boolean);

      const contextParts = [
        `Оценённых: ${rated.length}`,
        `В очереди: ${wish.length}`,
        topTags.length ? `Теги: ${topTags.join(", ")}` : "Теги: —",
        recentRated.length ? `Недавно оценённые: ${recentRated.join(", ")}` : "Недавно оценённые: —"
      ];

      const cleanUserPrompt = String(userPrompt || "").trim();
      const userLine = cleanUserPrompt || "Подбери 5 фильмов и 3 сериала для вечера.";

      return {
        system: "Ты киноман-куратор. Дай чёткие рекомендации на русском, с короткими пояснениями.",
        user: `Моя библиотека: ${contextParts.join(" • ")}. Запрос: ${userLine}. Дай список с кратким описанием и где смотреть (если знаешь).`
      };
    }

    async function requestTips(){
      if(!els.tipsOutput || !els.tipsStatus) return;
      const key = OPENROUTER_API_KEY;
      if(!key){
        els.tipsStatus.textContent = "Нужно задать OPENROUTER_API_KEY в коде.";
        return;
      }

      const { system, user } = buildTipsPrompt(els.tipsPrompt?.value || "");
      els.tipsStatus.textContent = "Отправляем запрос в OpenRouter…";
      els.tipsSendBtn?.setAttribute("disabled", "true");

      try{
        const response = await fetch(`${OPENROUTER_BASE}/chat/completions`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${key}`,
          },
          body: JSON.stringify({
            model: OPENROUTER_MODEL,
            messages: [
              { role: "system", content: system },
              { role: "user", content: user },
            ],
            temperature: 0.7,
          }),
        });

        if(!response.ok){
          const errText = await response.text();
          throw new Error(errText || "OpenRouter API error");
        }

        const data = await response.json();
        const text = data?.choices?.[0]?.message?.content?.trim();
        els.tipsOutput.textContent = text || "Ответ пуст. Попробуй изменить запрос.";
        els.tipsStatus.textContent = "Готово! Можно уточнить запрос или попросить новые подборки.";
      }catch(err){
        els.tipsOutput.textContent = "Не удалось получить ответ. Проверь ключ и интернет.";
        els.tipsStatus.textContent = `Ошибка: ${err?.message || "Запрос не удался"}`;
      }finally{
        els.tipsSendBtn?.removeAttribute("disabled");
      }
    }

    function renderTips(){
      if(els.tipsStatus && !OPENROUTER_API_KEY){
        els.tipsStatus.textContent = "Нужно задать OPENROUTER_API_KEY в коде.";
      }
    }

// ========= Profile (dashboard) =========
    // Parse directors from saved string like "Nolan, Someone"
    function splitPeople(raw){
      return String(raw || "")
        .split(",")
        .map(x => x.trim())
        .filter(Boolean);
    }

    function getRated(){
      return movies.filter(m => (m.status || "watched") === "watched");
    }

    function uniqueSorted(arr){
      const seen = new Set();
      const out = [];
      for(const it of arr){
        const k = normalize(it);
        if(!k || seen.has(k)) continue;
        seen.add(k);
        out.push(it.trim());
      }
      return out.sort((a,b) => normalize(a).localeCompare(normalize(b), "ru"));
    }

    function getTopGenres(limit = 8){
      const counted = new Map();
      for(const m of movies){
        const genreRaw = m.omdb?.genre || "";
        const parts = String(genreRaw).split(",").map(x => x.trim()).filter(Boolean);
        for(const g of parts){
          const key = normalize(g);
          if(!key) continue;
          counted.set(key, (counted.get(key) || 0) + 1);
        }
      }
      return [...counted.entries()]
        .sort((a,b) => b[1]-a[1])
        .slice(0, limit)
        .map(([k,c]) => ({ name: k, count: c }));
    }

    function ensureProfileDatalists(){
      const rated = getRated();

      const directors = [];
      const actors = [];

      for(const m of rated){
        splitPeople(m.director).forEach(d => directors.push(d));

        const arr = Array.isArray(m.omdb?.actors) ? m.omdb.actors : [];
        for(const a of arr) actors.push(a);
      }

      els.directorDatalist.innerHTML = uniqueSorted(directors).map(x => `<option value="${escapeHtml(x)}"></option>`).join("");
      els.actorDatalist.innerHTML = uniqueSorted(actors).map(x => `<option value="${escapeHtml(x)}"></option>`).join("");
    }

    function makeMiniItem(movie){
      const posterUrl = movie.omdb?.posterUrl || null;
      const { final } = computeScores(movie.scores);
      const year = movie.year ? String(movie.year) : "—";

      const el = document.createElement("div");
      el.className = "miniItem";

      const th = document.createElement("div");
      th.className = "miniThumb";
      if(posterUrl){
        const img = document.createElement("img");
        img.src = posterUrl;
        img.alt = "poster";
        img.loading = "lazy";
        th.appendChild(img);
      } else {
        th.textContent = "—";
      }

      const txt = document.createElement("div");
      txt.className = "miniTxt";

      const t = document.createElement("p");
      t.className = "miniTitle";
      t.textContent = movie.name || "Без названия";

      const meta = document.createElement("div");
      meta.className = "miniMeta";
      meta.innerHTML = `<span class="badgeRed">${formatFinalScore(final)}</span><span>${escapeHtml(year)}</span>`;

      txt.appendChild(t);
      txt.appendChild(meta);

      el.appendChild(th);
      el.appendChild(txt);

      el.addEventListener("click", () => {
        closePicker();
        goTo("rated", { openId: movie.id });
      });

      return el;
    }

    function makeTinyItem(movie){
      // compact inside favorite list
      const posterUrl = movie.omdb?.posterUrl || null;
      const { final } = computeScores(movie.scores);

      const el = document.createElement("div");
      el.className = "miniItem";

      const th = document.createElement("div");
      th.className = "miniThumb";
      if(posterUrl){
        const img = document.createElement("img");
        img.src = posterUrl;
        img.alt = "poster";
        img.loading = "lazy";
        th.appendChild(img);
      } else {
        th.textContent = "—";
      }

      const txt = document.createElement("div");
      txt.className = "miniTxt";

      const t = document.createElement("p");
      t.className = "miniTitle";
      t.textContent = movie.name || "Без названия";

      const meta = document.createElement("div");
      meta.className = "miniMeta";
      meta.innerHTML = `<span class="badgeRed">${formatFinalScore(final)}</span>${movie.year ? `<span>${escapeHtml(movie.year)}</span>` : ""}`;

      txt.appendChild(t);
      txt.appendChild(meta);

      el.appendChild(th);
      el.appendChild(txt);

      el.addEventListener("click", () => goTo("rated", { openId: movie.id }));

      return el;
    }

    // --- Picker modal (favorite movie/series selection) ---
    let pickerMode = null; // "movie" | "series" | "wishSeries"
    function openPicker(mode){
      pickerMode = mode;
      els.pickerTitle.textContent = mode === "series" ? "Выбрать любимый сериал" : (mode === "wishSeries" ? "Выбрать сериал из очереди" : "Выбрать любимый фильм");
      els.pickerHint.textContent = (mode === "wishSeries") ? "Только из “Буду смотреть” → Сериалы" : "Только из твоих оценённых (локальная база)";
      els.pickerSearch.value = "";
      els.pickerList.innerHTML = "";
      els.pickerModal.classList.add("show");
      els.pickerModal.setAttribute("aria-hidden", "false");
      renderPickerList();
      els.pickerSearch.focus();
    }

    function closePicker(){
      els.pickerModal.classList.remove("show");
      els.pickerModal.setAttribute("aria-hidden", "true");
      pickerMode = null;
    }

    function getTypeOfMovie(m){
      const tt = normalize(m.omdb?.type);
      if(tt === "series" || tt === "tv-series") return "series";
      if(tt === "movie") return "movie";
      return null;
    }

    function renderPickerList(){
      const q = normalize(els.pickerSearch.value);
      const rated = getRated();
      const modeNow = pickerMode; // capture current mode for stable selection

      let list = (modeNow === "wishSeries")
        ? movies.filter(m => (m.status||"watched")==="wish" && getWishKindForMovie(m)==="series")
        : rated;
      if(modeNow && modeNow !== "wishSeries"){
        list = list.filter(m => getTypeOfMovie(m) === modeNow);
      }
      if(q){
        list = list.filter(m => movieMatchesQuery(m, q));
      }

      // sort: best match (newest) for a stable feel
      list = list.slice().sort((a,b) => (b.createdAt ?? 0) - (a.createdAt ?? 0)).slice(0, 60);

      els.pickerList.innerHTML = "";
      if(list.length === 0){
        const empty = document.createElement("div");
        empty.className = "small";
        empty.style.color = "var(--muted)";
        empty.style.padding = "6px 2px";
        empty.textContent = "Ничего не найдено.";
        els.pickerList.appendChild(empty);
        return;
      }

      list.forEach(m => {
        const item = makeMiniItem(m);
        item.addEventListener("click", () => {
          if(modeNow === "wishSeries"){
            closePicker();
            applyNowFromMovie(m);
            goTo("now");
            return;
          }
          if(modeNow === "series") profile.favSeriesId = m.id;
          else profile.favMovieId = m.id;
          saveProfile(profile);
          closePicker();
          renderProfile();
        }, { once:true });
        els.pickerList.appendChild(item);
      });
    }

    // --- Favorites computations ---
    function matchDirector(movie, directorName){
      const target = normalize(directorName);
      if(!target) return false;
      return splitPeople(movie.director).some(d => normalize(d) === target);
    }

    function matchActor(movie, actorName){
      const target = normalize(actorName);
      if(!target) return false;
      const arr = Array.isArray(movie.omdb?.actors) ? movie.omdb.actors : [];
      return arr.some(a => normalize(a) === target);
    }

    function computeGroupStats(list){
      if(!list.length) return { count: 0, avg: null };
      const finals = list.map(m => computeScores(m.scores).final);
      const avg = finals.reduce((a,b)=>a+b,0) / finals.length;
      return { count: list.length, avg };
    }

    function renderFavMovieCard(mode){
      const isSeries = mode === "series";
      const id = isSeries ? profile.favSeriesId : profile.favMovieId;
      const card = isSeries ? els.favSeriesCard : els.favMovieCard;

      card.innerHTML = "";

      const head = document.createElement("div");
      head.className = "h";
      head.innerHTML = `<div><p class="t">${isSeries ? "Любимый сериал" : "Любимый фильм"}</p><div class="s">Это витрина твоего вкуса</div></div>`;
      card.appendChild(head);

      const rated = getRated();
      const movie = id ? rated.find(m => m.id === id) : null;

      if(!movie){
        const empty = document.createElement("div");
        empty.className = "favEmpty";
        empty.innerHTML = `<div>${isSeries ? "Любимый сериал не выбран" : "Любимый фильм не выбран"}</div>`;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "primary";
        btn.textContent = "Выбрать из оценённых";
        btn.addEventListener("click", () => openPicker(isSeries ? "series" : "movie"));
        empty.appendChild(btn);
        card.appendChild(empty);
        return;
      }

      const posterUrl = movie.omdb?.posterUrl || null;
      const { final } = computeScores(movie.scores);

      const row = document.createElement("div");
      row.className = "favMovieRow";

      const poster = document.createElement("div");
      poster.className = "favPoster";
      if(posterUrl){
        const img = document.createElement("img");
        img.src = posterUrl;
        img.alt = "poster";
        img.loading = "lazy";
        poster.appendChild(img);
      } else {
        poster.textContent = "Нет постера";
      }

      const meta = document.createElement("div");
      meta.className = "favMeta";

      const name = document.createElement("p");
      name.className = "favName";
      name.textContent = movie.name || "Без названия";

      const sub = document.createElement("div");
      sub.className = "favSub";

      // year + score + small "open in rated" icon
      const scoreRow = document.createElement("div");
      scoreRow.className = "favScoreRow";

      if(movie.year){
        const y = document.createElement("span");
        y.textContent = String(movie.year);
        scoreRow.appendChild(y);
      }

      const badge = document.createElement("span");
      badge.className = "badgeRed";
      badge.textContent = formatFinalScore(final);
      scoreRow.appendChild(badge);

      const openIcon = document.createElement("button");
      openIcon.type = "button";
      openIcon.className = "openRatedIcon";
      openIcon.textContent = "▶";
      openIcon.title = "Открыть в оценённых";
      openIcon.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        goTo("rated", { openId: movie.id });
      });
      scoreRow.appendChild(openIcon);

      sub.appendChild(scoreRow);

      const btns = document.createElement("div");
      btns.className = "btns";
      btns.style.justifyContent = "flex-start";

      const changeBtn = document.createElement("button");
      changeBtn.type = "button";
      changeBtn.textContent = "Сменить";
      changeBtn.addEventListener("click", () => openPicker(isSeries ? "series" : "movie"));

      btns.appendChild(changeBtn);

      meta.appendChild(name);
      meta.appendChild(sub);
      meta.appendChild(btns);

      row.appendChild(poster);
      row.appendChild(meta);

      card.appendChild(row);
    }

    function renderFavDirectorCard(){
      const card = els.favDirectorCard;
      card.innerHTML = "";

      const head = document.createElement("div");
      head.className = "h";
      head.innerHTML = `<div><p class="t">Любимый режиссёр</p><div class="s">Выбран на основе твоих оценённых фильмов</div></div>`;
      card.appendChild(head);

      const name = String(profile.favDirectorName || "").trim();
      const rated = getRated();
      const list = name ? rated.filter(m => matchDirector(m, name)) : [];
      const st = computeGroupStats(list);

      if(!name){
        const empty = document.createElement("div");
        empty.className = "favEmpty";
        empty.innerHTML = `<div>Любимый режиссёр не выбран</div>`;

        const field = document.createElement("div");
        field.className = "filterRow";
        field.innerHTML = `<label for="favDirectorInput">Выбрать из базы</label>
          <input id="favDirectorInput" type="text" list="directorDatalist" placeholder="Начни вводить..." maxlength="80" />`;

        const btnRow = document.createElement("div");
        btnRow.className = "btns";
        btnRow.style.justifyContent = "flex-start";

        const setBtn = document.createElement("button");
        setBtn.type = "button";
        setBtn.className = "primary";
        setBtn.textContent = "Выбрать";

        setBtn.addEventListener("click", () => {
          const v = document.getElementById("favDirectorInput").value.trim();
          if(!v){ toast("Выбери режиссёра из твоей базы 🙂"); return; }
          profile.favDirectorName = v;
          saveProfile(profile);
          closePicker();
          renderProfile();
        });

        btnRow.appendChild(setBtn);
        empty.appendChild(field);
        empty.appendChild(btnRow);
        card.appendChild(empty);
        return;
      }

      const title = document.createElement("div");
      title.className = "favName";
      title.textContent = name;

      const stats = document.createElement("div");
      stats.className = "favStats";
      stats.innerHTML = `<div class="favStat">Фильмов: <b>${st.count}</b></div><div class="favStat">Средняя: <b>${st.avg === null ? "—" : formatFinalScore(st.avg)}</b></div>`;

      const btnRow = document.createElement("div");
      btnRow.className = "btns";
      btnRow.style.justifyContent = "flex-start";

      const toggleBtn = document.createElement("button");
      toggleBtn.type = "button";
      toggleBtn.className = "primary";
      toggleBtn.textContent = "Показать фильмы";

      const clearBtn = document.createElement("button");
      clearBtn.type = "button";
      clearBtn.textContent = "Сбросить";
      clearBtn.className = "danger";

      const listWrap = document.createElement("div");
      listWrap.className = "favList";
      list.slice().sort((a,b)=> (b.createdAt??0)-(a.createdAt??0)).slice(0, 12).forEach(m => listWrap.appendChild(makeTinyItem(m)));

      toggleBtn.addEventListener("click", () => {
        const show = !listWrap.classList.contains("show");
        listWrap.classList.toggle("show", show);
        toggleBtn.textContent = show ? "Скрыть фильмы" : "Показать фильмы";
      });

      clearBtn.addEventListener("click", () => {
        profile.favDirectorName = "";
        saveProfile(profile);
        renderProfile();
      });

      btnRow.appendChild(toggleBtn);
      btnRow.appendChild(clearBtn);

      card.appendChild(title);
      card.appendChild(stats);
      card.appendChild(btnRow);
      if(st.count) card.appendChild(listWrap);
    }

    function renderFavActorCard(){
      const card = els.favActorCard;
      card.innerHTML = "";

      const head = document.createElement("div");
      head.className = "h";
      head.innerHTML = `<div><p class="t">Любимый актёр</p><div class="s">Актёры берутся из OMDb → Actors</div></div>`;
      card.appendChild(head);

      const name = String(profile.favActorName || "").trim();
      const rated = getRated();
      const list = name ? rated.filter(m => matchActor(m, name)) : [];
      const st = computeGroupStats(list);

      if(!name){
        const empty = document.createElement("div");
        empty.className = "favEmpty";
        empty.innerHTML = `<div>Любимый актёр не выбран</div>`;

        const field = document.createElement("div");
        field.className = "filterRow";
        field.innerHTML = `<label for="favActorInput">Выбрать из базы</label>
          <input id="favActorInput" type="text" list="actorDatalist" placeholder="Начни вводить..." maxlength="80" />`;

        const btnRow = document.createElement("div");
        btnRow.className = "btns";
        btnRow.style.justifyContent = "flex-start";

        const setBtn = document.createElement("button");
        setBtn.type = "button";
        setBtn.className = "primary";
        setBtn.textContent = "Выбрать";

        setBtn.addEventListener("click", () => {
          const v = document.getElementById("favActorInput").value.trim();
          if(!v){ toast("Выбери актёра из твоей базы 🙂"); return; }
          profile.favActorName = v;
          saveProfile(profile);
          closePicker();
          renderProfile();
        });

        btnRow.appendChild(setBtn);
        empty.appendChild(field);
        empty.appendChild(btnRow);
        card.appendChild(empty);
        return;
      }

      const title = document.createElement("div");
      title.className = "favName";
      title.textContent = name;

      const stats = document.createElement("div");
      stats.className = "favStats";
      stats.innerHTML = `<div class="favStat">Фильмов: <b>${st.count}</b></div><div class="favStat">Средняя: <b>${st.avg === null ? "—" : formatFinalScore(st.avg)}</b></div>`;

      const btnRow = document.createElement("div");
      btnRow.className = "btns";
      btnRow.style.justifyContent = "flex-start";

      const toggleBtn = document.createElement("button");
      toggleBtn.type = "button";
      toggleBtn.className = "primary";
      toggleBtn.textContent = "Показать фильмы";

      const clearBtn = document.createElement("button");
      clearBtn.type = "button";
      clearBtn.textContent = "Сбросить";
      clearBtn.className = "danger";

      const listWrap = document.createElement("div");
      listWrap.className = "favList";
      list.slice().sort((a,b)=> (b.createdAt??0)-(a.createdAt??0)).slice(0, 12).forEach(m => listWrap.appendChild(makeTinyItem(m)));

      toggleBtn.addEventListener("click", () => {
        const show = !listWrap.classList.contains("show");
        listWrap.classList.toggle("show", show);
        toggleBtn.textContent = show ? "Скрыть фильмы" : "Показать фильмы";
      });

      clearBtn.addEventListener("click", () => {
        profile.favActorName = "";
        saveProfile(profile);
        renderProfile();
      });

      btnRow.appendChild(toggleBtn);
      btnRow.appendChild(clearBtn);

      card.appendChild(title);
      card.appendChild(stats);
      card.appendChild(btnRow);
      if(st.count) card.appendChild(listWrap);
    }

    function renderProfile(){
      ensureProfileDatalists();

      // Personalization: tagline
      if(els.profileTagline){
        els.profileTagline.value = String(profile.tagline || "");
      }
      if(els.profileSubtitle){
        els.profileSubtitle.textContent = (profile.tagline && String(profile.tagline).trim())
          ? String(profile.tagline).trim()
          : "Твоя личная библиотека фильмов и сериалов";
      }

      // Tiles
      const rated = getRated();
      const wishCount = movies.filter(m => (m.status || "watched") === "wish").length;
      const favCount = movies.filter(m => !!m.favorite).length;

      const avg = rated.length ? (rated.map(m => computeScores(m.scores).final).reduce((a,b)=>a+b,0) / rated.length) : null;

      els.profileTiles.innerHTML = "";
      const tiles = [
        { k: "Оценено", n: rated.length },
        { k: "Буду смотреть", n: wishCount },
        { k: "Избранное", n: favCount },
        { k: "Средняя оценка", n: avg === null ? "—" : formatFinalScore(avg) },
      ];
      tiles.forEach(t => {
        const d = document.createElement("div");
        d.className = "tile";
        d.innerHTML = `<div class="n">${escapeHtml(t.n)}</div><div class="k">${escapeHtml(t.k)}</div>`;
        els.profileTiles.appendChild(d);
      });


      // Watching week stats (Now Watching)
      if(els.profileWatchingWeek){
        const week = sumMinutesLast7Days();
        const streak = computeStreak();
        const { watched, total, pct } = computeNowProgress();

        els.profileWatchingWeek.innerHTML = "";
        const head = document.createElement("div");
        head.className = "secHead";
        head.innerHTML = `<h3>Просмотр за неделю</h3><div class="small">По “Смотрю сейчас”</div>`;
        els.profileWatchingWeek.appendChild(head);

        const row = document.createElement("div");
        row.className = "favStats";
        row.innerHTML = `
          <div class="favStat">За 7 дней: <b>${week.eps} серий</b></div>
          <div class="favStat">Время: <b>${formatMinutes(week.minutes)}</b></div>
          <div class="favStat">Стрик: <b>${nowState.streakOn ? (streak + " дн.") : "выкл."}</b></div>
          <div class="favStat">Текущий прогресс: <b>${total ? `${watched}/${total} (${pct ?? 0}%)` : watched}</b></div>
        `;
        els.profileWatchingWeek.appendChild(row);

        if(nowState.goalEps > 0){
          const pctGoal = Math.min(100, Math.round((week.eps / nowState.goalEps)*100));
          const bar = document.createElement("div");
          bar.className = "progressBar";
          const fill = document.createElement("div");
          fill.style.width = String(pctGoal) + "%";
          bar.appendChild(fill);

          const note = document.createElement("div");
          note.className = "small";
          note.style.marginTop = "8px";
          note.style.color = "var(--muted)";
          note.textContent = `Цель недели: ${week.eps}/${nowState.goalEps} (${pctGoal}%)`;

          els.profileWatchingWeek.appendChild(bar);
          els.profileWatchingWeek.appendChild(note);
        }else{
          const note = document.createElement("div");
          note.className = "small";
          note.style.marginTop = "8px";
          note.style.color = "var(--muted)";
          note.textContent = "Можешь поставить цель недели во вкладке “Смотрю сейчас”.";
          els.profileWatchingWeek.appendChild(note);
        }
      }

      // Scores analytics (simple taste insights)
      if(els.profileScores){
        const crit = [
          { key: "overall",  label: "Общее" },
          { key: "engage",   label: "Вовлечённость" },
          { key: "emotions", label: "Эмоции" },
        ];
        const sums = { overall:0, engage:0, emotions:0 };
        for(const m of rated){
          sums.overall  += clamp(Number(m?.scores?.overall ?? 0), 0, 10);
          sums.engage   += clamp(Number(m?.scores?.engage ?? 0), 0, 10);
          sums.emotions += clamp(Number(m?.scores?.emotions ?? 0), 0, 10);
        }
        const avgs = {
          overall:  rated.length ? (sums.overall  / rated.length) : null,
          engage:   rated.length ? (sums.engage   / rated.length) : null,
          emotions: rated.length ? (sums.emotions / rated.length) : null,
        };

        let topKey = null;
        if(rated.length){
          topKey = Object.keys(avgs).sort((a,b)=> (avgs[b] ?? -1) - (avgs[a] ?? -1))[0];
        }
        const topLabel = topKey === "emotions" ? "эмоции" : (topKey === "engage" ? "вовлечённость" : "общее впечатление");

        els.profileScores.innerHTML = "";
        const head = document.createElement("div");
        head.className = "secHead";
        head.innerHTML = `<h3>Твоя аналитика оценок</h3><div class="small">Средние по шкалам</div>`;
        els.profileScores.appendChild(head);

        const wrap = document.createElement("div");
        wrap.className = "favStats";
        crit.forEach(c => {
          const box = document.createElement("div");
          box.className = "favStat";
          box.innerHTML = `${escapeHtml(c.label)}: <b>${avgs[c.key] === null ? "—" : formatFinalScore(avgs[c.key])}</b>`;
          wrap.appendChild(box);
        });
        els.profileScores.appendChild(wrap);

        const insight = document.createElement("div");
        insight.className = "small";
        insight.style.marginTop = "8px";
        insight.style.color = "var(--muted)";
        insight.textContent = rated.length ? (`Инсайт: ты чаще всего высоко оцениваешь ${topLabel}.`) : "Добавь оценки, чтобы увидеть инсайты.";
        els.profileScores.appendChild(insight);
      }

      // Genres
      const top = getTopGenres(10);
      els.profileGenreChips.innerHTML = "";
      if(!top.length){
        const sm = document.createElement("div");
        sm.className = "small";
        sm.style.color = "var(--muted)";
        sm.textContent = "Пока нет жанров — добавь фильм через OMDb, чтобы подтянулись жанры.";
        els.profileGenreChips.appendChild(sm);
      } else {
        top.forEach(g => {
          const c = document.createElement("div");
          c.className = "genreChip";
          c.textContent = g.name;
          els.profileGenreChips.appendChild(c);
        });
      }

      // Manual favorite genres (up to 2)
      if(els.profileManualGenreChips){
        const allGenres = Array.from(new Set(getRated().flatMap(m => (String(m.genre || m.genres || m.omdbGenre || "")
          .split(",")
          .map(s => s.trim())
          .filter(Boolean))))).sort((a,b)=>a.localeCompare(b,"ru"));

        els.profileManualGenreChips.innerHTML = "";
        if(!allGenres.length){
          const sm = document.createElement("div");
          sm.className = "small";
          sm.style.color = "var(--muted)";
          sm.textContent = "Пока нет жанров — добавь фильм через OMDb, чтобы выбрать любимые жанры вручную.";
          els.profileManualGenreChips.appendChild(sm);
        } else {
          const selected = new Set(Array.isArray(profile.manualGenres) ? profile.manualGenres : []);
          allGenres.slice(0, 30).forEach(name => {
            const c = document.createElement("div");
            c.className = "genreChip isPick" + (selected.has(name) ? " on" : "");
            c.textContent = name;
            c.dataset.genre = name;
            c.title = "Клик — выбрать/убрать";
            els.profileManualGenreChips.appendChild(c);
          });
        }
      }

      // Favorite cards
      renderFavMovieCard("movie");
      renderFavMovieCard("series");
      renderFavDirectorCard();
      renderFavActorCard();

      updateSupabaseUi();

      // Best + recent
      els.bestList.innerHTML = "";
      els.recentRatedList.innerHTML = "";

      const best = rated.slice().sort((a,b)=> computeScores(b.scores).final - computeScores(a.scores).final).slice(0,3);
      const recent = rated.slice().sort((a,b)=> (b.createdAt??0)-(a.createdAt??0)).slice(0,3);

      if(!best.length){
        const e = document.createElement("div");
        e.className = "small";
        e.style.color = "var(--muted)";
        e.textContent = "Пока пусто.";
        els.bestList.appendChild(e);
      } else {
        best.forEach(m => els.bestList.appendChild(makeMiniItem(m)));
      }

      if(!recent.length){
        const e = document.createElement("div");
        e.className = "small";
        e.style.color = "var(--muted)";
        e.textContent = "Пока пусто.";
        els.recentRatedList.appendChild(e);
      } else {
        recent.forEach(m => els.recentRatedList.appendChild(makeMiniItem(m)));
      }
    }

    // modal listeners
    els.pickerCloseBtn.addEventListener("click", closePicker);
    els.pickerBackdrop.addEventListener("click", (e) => {
      if(e.target?.dataset?.close) closePicker();
    });
    els.pickerSearch.addEventListener("input", renderPickerList);

    // profile button -> profile page
    els.profileBtn.addEventListener("click", (e) => {
      e.preventDefault();
      goTo("profile");
    });

    // Profile personalization inputs
    if(els.profileTagline){
      els.profileTagline.addEventListener("input", () => {
        profile.tagline = String(els.profileTagline.value || "");
        saveProfile(profile);
        if(els.profileSubtitle){
          els.profileSubtitle.textContent = (profile.tagline && String(profile.tagline).trim())
            ? String(profile.tagline).trim()
            : "Твоя личная библиотека фильмов и сериалов";
        }
      });
    }

    if(els.profileManualGenreChips){
      els.profileManualGenreChips.addEventListener("click", (e) => {
        const el = e.target.closest(".genreChip.isPick");
        if(!el) return;
        const g = String(el.dataset.genre || "").trim();
        if(!g) return;
        const arr = Array.isArray(profile.manualGenres) ? profile.manualGenres.slice() : [];
        const idx = arr.indexOf(g);
        if(idx >= 0){
          arr.splice(idx,1);
        } else {
          if(arr.length >= 2){
            toast("Можно выбрать максимум 2 жанра");
            return;
          }
          arr.push(g);
        }
        profile.manualGenres = arr;
        saveProfile(profile);
        renderProfile();
      });
    }

    function readSupabaseCredentials(){
      const email = String(els.supabaseEmail?.value || "").trim();
      const password = String(els.supabasePassword?.value || "").trim();
      return { email, password };
    }

    if(els.supabaseRegisterBtn){
      els.supabaseRegisterBtn.addEventListener("click", async () => {
        if(!supabaseClient){
          toast("Supabase недоступен");
          return;
        }
        const { email, password } = readSupabaseCredentials();
        if(!email || !password){
          toast("Заполни email и пароль");
          return;
        }
        if(password.length < 6){
          toast("Слишком короткий пароль", "Минимум 6 символов.");
          return;
        }
        setSupabaseStatus("Регистрирую…");
        const { error } = await supabaseClient.auth.signUp({ email, password });
        if(error){
          setSupabaseStatus("Ошибка регистрации", true);
          toast("Регистрация", error.message || "Не удалось зарегистрироваться");
          return;
        }
        setSupabaseStatus("Проверь почту для подтверждения");
        toast("Почта отправлена", "Подтверди email, затем войди.");
      });
    }

    if(els.supabaseLoginBtn){
      els.supabaseLoginBtn.addEventListener("click", async () => {
        if(!supabaseClient){
          toast("Supabase недоступен");
          return;
        }
        const { email, password } = readSupabaseCredentials();
        if(!email || !password){
          toast("Заполни email и пароль");
          return;
        }
        setSupabaseStatus("Вхожу…");
        const { error } = await supabaseClient.auth.signInWithPassword({ email, password });
        if(error){
          setSupabaseStatus("Ошибка входа", true);
          toast("Вход", error.message || "Не удалось войти");
          return;
        }
        if(els.supabasePassword) els.supabasePassword.value = "";
        setSupabaseStatus("Вход выполнен");
        toast("Успешный вход");
      });
    }

    if(els.supabaseLogoutBtn){
      els.supabaseLogoutBtn.addEventListener("click", async () => {
        if(!supabaseClient) return;
        await supabaseClient.auth.signOut();
        supabaseUser = null;
        updateSupabaseUi();
        setSupabaseStatus("Вышли из аккаунта");
      });
    }

    if(els.supabaseSyncBtn){
      els.supabaseSyncBtn.addEventListener("click", async () => {
        if(!supabaseClient || !supabaseUser){
          toast("Нужно войти", "Сначала войди в аккаунт.");
          return;
        }
        await pullLibraryFromSupabase("manual");
      });
    }


// ========= Home =========
    function makePosterSmall(url){
      const box = document.createElement("div");
      box.className = "posterSm";
      if(url){
        const img = document.createElement("img");
        img.src = url;
        img.alt = "poster";
        img.loading = "lazy";
        box.appendChild(img);
      } else {
        box.textContent = "No poster";
      }
      return box;
    }

    function renderHome(){
      const rated = movies
        .filter(m => (m.status || "watched") === "watched")
        .sort((a,b) => (b.createdAt ?? 0) - (a.createdAt ?? 0))
        .slice(0,4);

      if(rated.length === 0){
        els.recentWrap.innerHTML = `<div class="emptyNote">Пока нет оценённых — перейди в “Оценить” и добавь первый.</div>`;
        return;
      }

      const grid = document.createElement("div");
      grid.className = "recentGrid";

      rated.forEach(m => {
        const { final } = computeScores(m.scores);
        const card = document.createElement("div");
        card.className = "recentCard";
        card.addEventListener("click", () => goTo("rated", { openId: m.id }));

        card.appendChild(makePosterSmall(m.omdb?.posterUrl || null));

        const t = document.createElement("div");
        t.className = "recentTxt";

        const name = document.createElement("p");
        name.className = "recentName";
        name.textContent = m.name || "Без названия";

        const badge = document.createElement("div");
        badge.className = "scoreBadge";
        badge.textContent = formatFinalScore(final);

        t.appendChild(name);
        t.appendChild(badge);

        card.appendChild(t);
        grid.appendChild(card);
      });

      els.recentWrap.innerHTML = "";
      els.recentWrap.appendChild(grid);
    }

    // ========= Sliders =========
    function renderSliders(){
      els.sliders.innerHTML = "";
      CRITERIA.forEach(c => {
        const row = document.createElement("div");
        row.className = "row";

        const top = document.createElement("div");
        top.className = "rowTop";

        const title = document.createElement("p");
        title.className = "rowTitle";
        title.textContent = c.label;

        const pill = document.createElement("span");
        pill.className = "valuePill";
        pill.textContent = String(current[c.key]);

        top.appendChild(title);
        top.appendChild(pill);

const range = document.createElement("input");
range.type = "range";
range.className = "scoreRange";
range.min = "0";
range.max = "10";
range.step = "0.01";
range.value = String(current[c.key]);

// set initial fill %
const setRangeFill = () => {
  const v = clamp(Number(range.value), 0, 10);
  const p = (v / 10) * 100;
  range.style.setProperty("--p", p.toFixed(1) + "%");
};
setRangeFill();

range.addEventListener("input", () => {
  const prevInt = current[c.key];
  const raw = clamp(Number(range.value), 0, 10);
  const nextInt = clamp(Math.round(raw), 0, 10);

  // smooth visual fill while dragging
  const p = (raw / 10) * 100;
  range.style.setProperty("--p", p.toFixed(1) + "%");

  // update integer value + UI only when integer changes
  if(prevInt !== nextInt){
    current[c.key] = nextInt;

    pill.classList.remove("bump");
    void pill.offsetWidth;
    pill.classList.add("bump");
    pill.textContent = String(nextInt);

    updateTotals();
  }
});


// snap to integer on release (keeps drag smooth, but final value is clean)
function snapToInt(){
  const raw = clamp(Number(range.value), 0, 10);
  const snapped = clamp(Math.round(raw), 0, 10);
  range.value = String(snapped);
  const p = (snapped / 10) * 100;
  range.style.setProperty("--p", p.toFixed(1) + "%");
}
range.addEventListener("change", snapToInt);
range.addEventListener("mouseup", snapToInt);
range.addEventListener("touchend", snapToInt);

row.appendChild(top);
row.appendChild(range);
        els.sliders.appendChild(row);
      });
    }

    function updateTotals(){
      const { sum, final } = computeScores(current);
      els.sumScore.textContent = format1(sum);
      els.avgScore.textContent = formatFinalScore(final);
    }

    function resetSliders(){
      CRITERIA.forEach(c => current[c.key] = 0);
      renderSliders();
      updateTotals();
    }

    // ========= OMDb autocomplete =========
    const DEBOUNCE_MS = 650;
    let omdbDebounceTimer = null;
    let lastQuery = "";

    function setOmdbStatus(text, isError=false){
      els.omdbStatus.innerHTML = text
        ? (isError ? `<b>Ошибка:</b> ${escapeHtml(text)}` : escapeHtml(text))
        : "";
    }

    function hideResults(){
      els.omdbResults.classList.remove("show");
      els.omdbResults.innerHTML = "";
    }

    function showResults(items){
      els.omdbResults.innerHTML = "";

      for(const it of items){
        const row = document.createElement("div");
        row.className = "resItem";

        const thumb = document.createElement("div");
        thumb.className = "miniThumb";
        if(it.Poster && it.Poster !== "N/A"){
          const img = document.createElement("img");
          img.src = it.Poster;
          img.alt = "poster";
          img.loading = "lazy";
          thumb.appendChild(img);
        } else {
          thumb.textContent = "—";
        }

        const txt = document.createElement("div");
        txt.className = "resTxt";

        const t = document.createElement("p");
        t.className = "resTitle";
        t.textContent = it.Title || "Без названия";

        const s = document.createElement("div");
        s.className = "resSub";
        s.textContent = `${it.Year || "—"} • ${typeLabel(it.Type)}`;

        txt.appendChild(t);
        txt.appendChild(s);

        row.appendChild(thumb);
        row.appendChild(txt);

        row.addEventListener("click", async () => {
          hideResults();
          await applyOmdbByImdbId(it.imdbID);
        });

        els.omdbResults.appendChild(row);
      }

      els.omdbResults.classList.add("show");
    }

    async function omdbFetch(params){
      const url = new URL(OMDB_BASE);
      Object.entries(params).forEach(([k,v]) => url.searchParams.set(k, String(v)));
      const res = await fetch(url.toString());
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    }

    async function searchOmdb(query){
      const q = String(query || "").trim();

      if(q.length < 3){
        hideResults();
        lastQuery = "";
        setOmdbStatus("Введи минимум 3 символа, чтобы увидеть подсказки.");
        return;
      }

      if(q === lastQuery && els.omdbResults.classList.contains("show")) return;
      lastQuery = q;

      setOmdbStatus("Ищу…");
      hideResults();

      try{
        const data = await omdbFetch({ s: q }); // movie + series
        if(data.Response === "False"){
          setOmdbStatus(data.Error || "Ничего не найдено.", true);
          return;
        }

        const list = Array.isArray(data.Search) ? data.Search.slice(0, 10) : [];
        if(list.length === 0){
          setOmdbStatus("Ничего не найдено.", true);
          return;
        }

        setOmdbStatus("Выбери вариант из списка ниже 👇");
        showResults(list);
      }catch{
        setOmdbStatus("Не удалось связаться с OMDb. Проверь интернет и попробуй ещё раз.", true);
      }
    }

    async function applyOmdbByImdbId(imdbID){
      setOmdbStatus("Загружаю детали…");

      try{
        const d = await omdbFetch({ i: imdbID, plot: "short" });
        if(d.Response === "False"){
          setOmdbStatus(d.Error || "Не удалось получить детали.", true);
          return;
        }

        if(d.Title && d.Title !== "N/A") els.movieName.value = d.Title;
        if(d.Director && d.Director !== "N/A") els.director.value = d.Director;

        if(d.Year && d.Year !== "N/A"){
          const match = String(d.Year).match(/\d{4}/);
          if(match) els.year.value = match[0];
        }

        const posterUrl = (d.Poster && d.Poster !== "N/A") ? d.Poster : null;

        omdbMetaDraft = {
  title: (d.Title && d.Title !== "N/A") ? d.Title : null,
          imdbID: (d.imdbID && d.imdbID !== "N/A") ? d.imdbID : null,
  posterUrl: (d.Poster && d.Poster !== "N/A") ? d.Poster : null,
  genre: (d.Genre && d.Genre !== "N/A") ? d.Genre : null,
  runtime: (d.Runtime && d.Runtime !== "N/A") ? d.Runtime : null,
  imdbRating: (d.imdbRating && d.imdbRating !== "N/A") ? d.imdbRating : null,
  type: (d.Type && d.Type !== "N/A") ? d.Type : null,

  // 🔥 ВАЖНО: ЭТО ДОЛЖНО БЫТЬ ВНУТРИ ЭТОГО ЖЕ ОБЪЕКТА
  actors: (d.Actors && d.Actors !== "N/A")
    ? d.Actors.split(",").map(a => a.trim()).filter(Boolean)
    : []
};


        setOmdbStatus("Готово: данные подставлены. Теперь поставь оценки и нажми “Добавить”.");
      }catch{
        setOmdbStatus("Ошибка при загрузке деталей из OMDb.", true);
      }
    }

    function scheduleOmdbAutocomplete(){
      const q = els.movieName.value.trim();

      if(q.length < 3){
        if(omdbDebounceTimer) clearTimeout(omdbDebounceTimer);
        hideResults();
        lastQuery = "";
        setOmdbStatus("Введи минимум 3 символа, чтобы увидеть подсказки.");
        return;
      }

      if(omdbDebounceTimer) clearTimeout(omdbDebounceTimer);
      omdbDebounceTimer = setTimeout(() => searchOmdb(q), DEBOUNCE_MS);
    }

    
    // ========= OMDb autocomplete for "Смотрю сейчас" =========
    let nowLastQuery = "";

    function nowHideOmdbResults(){
      if(els.nowOmdbResults) els.nowOmdbResults.classList.remove("show");
      if(els.nowOmdbResults) els.nowOmdbResults.innerHTML = "";
    }

    function nowSetOmdbStatus(msg, isError=false){
      if(!els.nowOmdbStatus) return;
      els.nowOmdbStatus.textContent = msg || "";
      els.nowOmdbStatus.style.color = isError ? "var(--bad)" : "var(--muted)";
    }

    function nowHideOmdbResults(){
      if(!els.nowOmdbResults) return;
      els.nowOmdbResults.innerHTML = "";
      els.nowOmdbResults.classList.remove("show");
    }

    function nowShowOmdbResults(items){
      if(!els.nowOmdbResults) return;
      els.nowOmdbResults.innerHTML = "";

      for(const it of items){
        const row = document.createElement("div");
        row.className = "resItem";
        const year = it.Year ? ` (${it.Year})` : "";
        row.innerHTML = `
          <div class="resPoster">${it.Poster && it.Poster!=="N/A" ? `<img src="${it.Poster}" alt="">` : ""}</div>
          <div class="resMeta">
            <div class="resTitle">${escapeHtml(it.Title || "")}${escapeHtml(year)}</div>
            <div class="resSub">Сериал • ${escapeHtml(it.imdbID || "")}</div>
          </div>
        `;

        row.addEventListener("click", async () => {
          try{
            nowSetOmdbStatus("Загружаю…");
            nowHideOmdbResults();
            // Ставим выбранный сериал активным по imdbID
            await nowApplyOmdbByImdbId(it.imdbID);
            nowSetOmdbStatus("Готово: сериал выбран и активирован.");
            goTo("now");
          }catch{
            nowSetOmdbStatus("Не удалось загрузить детали сериала из OMDb.", true);
          }
        });

        els.nowOmdbResults.appendChild(row);
      }

      els.nowOmdbResults.classList.add("show");
    }

    async function nowSearchOmdb(query){
      const q = String(query || "").trim();

      if(q.length < 3){
        nowHideOmdbResults();
        nowLastQuery = "";
        nowSetOmdbStatus("Введи минимум 3 символа, чтобы увидеть подсказки.");
        return;
      }

      if(q === nowLastQuery && els.nowOmdbResults?.classList.contains("show")) return;
      nowLastQuery = q;

      nowSetOmdbStatus("Ищу…");
      nowHideOmdbResults();

      try{
        // Поиск как во вкладке «Оценить», но только сериалы
        const data = await omdbFetch({ s: q, type: "series" });
        if(data.Response === "False"){
          nowSetOmdbStatus(data.Error || "Ничего не найдено.", true);
          return;
        }

        const list = Array.isArray(data.Search) ? data.Search.slice(0, 10) : [];
        if(list.length === 0){
          nowSetOmdbStatus("Ничего не найдено.", true);
          return;
        }

        nowSetOmdbStatus("Выбери вариант из списка ниже 👇");
        nowShowOmdbResults(list);
      }catch{
        nowSetOmdbStatus("Не удалось связаться с OMDb. Проверь интернет и попробуй ещё раз.", true);
      }
    }

    function scheduleNowOmdbAutocomplete(){
      if(!els.nowPick) return;
      const q = els.nowPick.value.trim();

      if(q.length < 3){
        if(omdbDebounceTimer) clearTimeout(omdbDebounceTimer);
        nowHideOmdbResults();
        nowSetOmdbStatus("Введи минимум 3 символа, чтобы увидеть подсказки.");
        return;
      }

      // быстрый фидбек, чтобы было видно что обработчик работает
      nowSetOmdbStatus("Ищу…");

      if(omdbDebounceTimer) clearTimeout(omdbDebounceTimer);
      omdbDebounceTimer = setTimeout(() => nowSearchOmdb(q), DEBOUNCE_MS);
    }

document.addEventListener("click", (e) => {
      const withinEval =
        els.omdbResults.contains(e.target) ||
        els.omdbSearchBtn.contains(e.target) ||
        els.movieName.contains(e.target);

      const withinNow = !!(
        els.nowOmdbResults && (els.nowOmdbResults.contains(e.target) ||
        els.nowOmdbSearchBtn?.contains(e.target) ||
        els.nowPick?.contains(e.target))
      );

      if(!withinEval) hideResults();
      if(!withinNow) nowHideOmdbResults();
    });

    els.movieName.addEventListener("input", scheduleOmdbAutocomplete);

    els.movieName.addEventListener("keydown", async (e) => {
      if(e.key === "Escape"){
        hideResults();
        return;
      }
      if(e.key === "Enter"){
        if(els.omdbResults.classList.contains("show")){
          e.preventDefault();
          const first = els.omdbResults.querySelector(".resItem");
          if(first) first.click();
          return;
        }
        e.preventDefault();
        await searchOmdb(els.movieName.value.trim());
      }
    });

    els.omdbSearchBtn.addEventListener("click", async () => {
      await searchOmdb(els.movieName.value.trim());
    });

    // ========= Add / Update =========
    function getWishKindForMovie(m){
      const t = getTypeOfMovie(m);
      return t === "series" ? "series" : "movie";
    }

    function getNextWishOrder(kind){
      const k = kind === "series" ? "series" : "movie";
      const wish = movies.filter(m => (m.status || "watched") === "wish" && getWishKindForMovie(m) === k);
      const max = wish.reduce((acc, m) => Math.max(acc, Number(m.queueOrder || 0)), 0);
      return max + 1;
    }

    function addMovie(){
      const name = els.movieName.value.trim();
      if(!name){
        toast("Впиши название 🙂");
        els.movieName.focus();
        return;
      }

      const director = els.director.value.trim();
      const yearNum = els.year.value === "" ? null : Number(els.year.value);
      const year = (yearNum === null || Number.isNaN(yearNum)) ? null : clamp(yearNum, 1888, 2100);

      const status = els.status.value || "watched";
      const tags = parseTags(els.tags.value);
      const notes = els.notes.value.trim();

      const id = makeId();

      const movie = {
        id,
        name,
        director,
        year,
        status,
        tags,
        notes,
        createdAt: Date.now(),
        scores: { ...current },
        favorite: false,
        queueOrder: status === "wish" ? getNextWishOrder(getWishKindForMovie({ omdb: omdbMetaDraft })) : null,
        omdb: omdbMetaDraft ? { ...omdbMetaDraft } : null,
      };

      movies.push(movie);
      saveMovies();

      // UX feedback
      toast(status === "wish" ? "Добавлено в 'Буду смотреть'" : "Добавлено в оценённые", name);

      // reset form
      els.movieName.value = "";
      els.director.value = "";
      els.year.value = "";
      els.status.value = "watched";
      els.tags.value = "";
      els.notes.value = "";
      omdbMetaDraft = null;
      els.omdbStatus.textContent = "";
      hideResults();

      resetSliders();
      renderEverything();

      goTo(status === "wish" ? "wish" : "rated", { openId: movie.id });
    }

    function addWishFromCurrentOmdb(){
      if(!omdbMetaDraft || !omdbMetaDraft.imdbID){
        toast("Сначала выбери фильм/сериал из OMDb 🙂");
        return;
      }

      const existing = movies.find(m => m.omdb?.imdbID && m.omdb.imdbID === omdbMetaDraft.imdbID);
      if(existing){
        existing.status = "wish";
        if(!existing.queueOrder) existing.queueOrder = getNextWishOrder(getWishKindForMovie(existing));
        saveMovies();
        // UX feedback
        toast("Перемещено в 'Буду смотреть'", existing.name || "Без названия");
        renderEverything();
        {
        const k = getWishKindForMovie(existing);
        wishKindActive = (k === "series") ? "series" : "movie";
        syncWishToggleButtons();
        goTo("wish");
      }
        return;
      }

      const yearNum = els.year.value === "" ? null : Number(els.year.value);
      const year = (yearNum === null || Number.isNaN(yearNum)) ? null : clamp(yearNum, 1888, 2100);

      const movie = {
        id: makeId(),
        name: els.movieName.value.trim() || "Без названия",
        director: els.director.value.trim(),
        year,
        status: "wish",
        tags: parseTags(els.tags.value),
        notes: els.notes.value.trim(),
        createdAt: Date.now(),
        scores: { overall: 0, engage: 0, emotions: 0 },
        favorite: false,
        queueOrder: getNextWishOrder(getWishKindForMovie({ omdb: omdbMetaDraft })),
        omdb: { ...omdbMetaDraft },
      };

      movies.push(movie);
      saveMovies();
      // UX feedback
      toast("Добавлено в 'Буду смотреть'", movie.name || "Без названия");
      renderEverything();
      {
      const k = getWishKindForMovie(movie);
      wishKindActive = (k === "series") ? "series" : "movie";
      syncWishToggleButtons();
      goTo("wish");
    }
    }

    function deleteMovie(id, opts = {}){
      // opts:
      // - muteAnim: disable entry animations for the following rerender (fallback path)
      // - softEl: details element to remove in-place (preferred to avoid list flicker)
      const softEl = opts.softEl || null;

      const m = movies.find(x => x.id === id);
      const name = m?.name || "Без названия";
      const wasWish = (m?.status || "watched") === "wish";
      const wishKind = wasWish ? getWishKindForMovie(m) : null;

      // Update data first
      movies = movies.filter(x => x.id !== id);
      saveMovies();

      // Preferred: remove only the deleted element from DOM (no full rerender -> no flicker)
      if(softEl){
        // Remove node if it's still in DOM
        if(softEl.parentElement){ try{ softEl.remove(); }catch(e){} }

        // Update minimal UI pieces that depend on the dataset
        renderNav();
        if(currentView === "rated"){
          // Update stats + pager text (list itself stays as-is, minus removed card)
          renderStats();
          const list = getRatedFilteredSorted();
          const totalPages = Math.max(1, Math.ceil(list.length / PAGE_SIZE));
          ratedPage = clamp(ratedPage, 1, totalPages);
          els.pageInfo.textContent = `Страница ${ratedPage} из ${totalPages}`;

          // If list became empty on the page, do a safe rerender for correctness
          if(!els.items.querySelector("details.item")){
            const mute = true;
            if(mute) document.body.classList.add("muteAnim");
            renderRated();
            requestAnimationFrame(() => setTimeout(() => document.body.classList.remove("muteAnim"), 140));
          }
        }else if(currentView === "wish"){
          // Update the visible wish list stats + empty state
          const k = wishKindActive === "series" ? "series" : "movie";
          const listEl  = k === "series" ? els.wishSeriesList  : els.wishMoviesList;
          const statsEl = k === "series" ? els.wishSeriesStats : els.wishMoviesStats;

          const remaining = getWishList(k);
          if(remaining.length === 0){
            listEl.innerHTML = `<div class="empty">Очередь пуста. Добавь что-нибудь из “Оценить”.</div>`;
            statsEl.textContent = "В очереди: 0";
          }else{
            statsEl.textContent = `В очереди: ${remaining.length}`;
          }
        }else if(currentView === "home"){
          // Home depends on recent list: lightweight refresh
          const mute = true;
          if(mute) document.body.classList.add("muteAnim");
          renderHome();
  renderNowHomeWidget();
          requestAnimationFrame(() => setTimeout(() => document.body.classList.remove("muteAnim"), 140));
        }else if(currentView === "profile"){
          const mute = true;
          if(mute) document.body.classList.add("muteAnim");
          renderProfile();
          requestAnimationFrame(() => setTimeout(() => document.body.classList.remove("muteAnim"), 140));
        }

        // UX feedback
        toast(wasWish ? "Удалено из очереди" : "Удалено", name);
        return;
      }

      // Fallback: full rerender (may flicker on some devices)
      const mute = opts.muteAnim !== false;
      if(mute) document.body.classList.add("muteAnim");
      renderEverything();
      if(mute){
        requestAnimationFrame(() => setTimeout(() => document.body.classList.remove("muteAnim"), 140));
      }

      toast(wasWish ? "Удалено из очереди" : "Удалено", name);
    }

    function deleteMovieConfirm(id, detailsEl){
      const m = movies.find(x => x.id === id);
      const name = m?.name ? `«${m.name}»` : "этот элемент";
      if(!confirm(`Удалить ${name}? Это действие нельзя отменить.`)) return;

      // UX: animate collapse, then delete (in-place remove to prevent flicker)
      if(detailsEl){
        detailsEl.classList.add("leaving");
        setTimeout(() => {
          animateRemoveDetails(detailsEl, () => {
            deleteMovie(id, { softEl: detailsEl, muteAnim: true });
          });
        }, 20);
      }else{
        deleteMovie(id, { muteAnim:true });
      }
    }

    function toggleFavorite(id){
  const m = movies.find(x => x.id === id);
  if(!m) return;
  m.favorite = !m.favorite;

  // remember for quick pulse after rerender
  lastFavPulseId = id;

  saveMovies();
  renderEverything();

  // UX feedback
  toast(m.favorite ? "Добавлено в избранное" : "Убрано из избранного", m.name || "Без названия");

  // clear soon (so other renders won't pulse)
  setTimeout(() => {
    if(lastFavPulseId === id) lastFavPulseId = null;
  }, 260);
}

    // ========= Rated list =========
    function getRatedFilteredSorted(){
      const q = normalize(els.search.value);
      const min = Number(els.minAvg.value || "0");
      const tagQ = els.tagFilter.value.trim();
      const onlyFav = !!els.onlyFav.checked;

      let arr = movies.filter(m => (m.status || "watched") === "watched");

      if(q) arr = arr.filter(m => movieMatchesQuery(m, q));
      if(min > 0) arr = arr.filter(m => computeScores(m.scores).final >= min);
      if(tagQ){
        const nt = normalize(tagQ);
        arr = arr.filter(m => (m.tags || []).map(t => normalize(t)).includes(nt));
      }
      if(onlyFav) arr = arr.filter(m => !!m.favorite);

      const sort = els.sort.value;
      if(sort === "best"){
        arr.sort((a,b) => {
          const aa = computeScores(a.scores).final;
          const bb = computeScores(b.scores).final;
          if(bb !== aa) return bb - aa;
          return (b.createdAt ?? 0) - (a.createdAt ?? 0);
        });
      } else if(sort === "emotions"){
        arr.sort((a,b) => {
          const aa = clamp(Number(a?.scores?.emotions ?? 0), 0, 10);
          const bb = clamp(Number(b?.scores?.emotions ?? 0), 0, 10);
          if(bb !== aa) return bb - aa;
          return (b.createdAt ?? 0) - (a.createdAt ?? 0);
        });
      } else if(sort === "engage"){
        arr.sort((a,b) => {
          const aa = clamp(Number(a?.scores?.engage ?? 0), 0, 10);
          const bb = clamp(Number(b?.scores?.engage ?? 0), 0, 10);
          if(bb !== aa) return bb - aa;
          return (b.createdAt ?? 0) - (a.createdAt ?? 0);
        });
      } else if(sort === "name"){
        arr.sort((a,b) => normalize(a.name).localeCompare(normalize(b.name), "ru"));
      } else if(sort === "year_desc"){
        arr.sort((a,b) => (b.year ?? -1) - (a.year ?? -1));
      } else {
        arr.sort((a,b) => (b.createdAt ?? 0) - (a.createdAt ?? 0));
      }

      return arr;
    }

    function renderStats(){
      const rated = movies.filter(m => (m.status || "watched") === "watched");
      const total = rated.length;
      const shown = getRatedFilteredSorted().length;

      if(total === 0){
        els.stats.textContent = "Оценённых: 0";
        return;
      }

      const finals = rated.map(m => computeScores(m.scores).final);
      const overallAvg = finals.reduce((a,b)=>a+b,0) / finals.length;

      let best = null;
      for(const m of rated){
        const f = computeScores(m.scores).final;
        if(!best || f > best.final) best = { name: m.name, final: f };
      }

      const shownTxt = (shown === total) ? "" : ` • Показано: ${shown}`;
      els.stats.textContent = `Оценённых: ${total}${shownTxt} • Общий средний: ${formatFinalScore(overallAvg)} • Лучший: ${best ? (best.name + " (" + formatFinalScore(best.final) + ")") : "—"}`;
    }

    function makeThumb(url){
      const box = document.createElement("div");
      box.className = "thumb";
      if(url){
        const img = document.createElement("img");
        img.src = url;
        img.alt = "poster";
        img.loading = "lazy";
        box.appendChild(img);
      }else{
        box.textContent = "No\nposter";
      }
      return box;
    }

    
    function setFavoriteActorFromChip(actorName){
      const name = String(actorName || "").trim();
      if(!name) return;
      profile.favActorName = name;
      saveProfile(profile);
      goTo("profile");
    }

    function buildActorsBlock(movie, q){
      const block = document.createElement("div");
      block.className = "textBlock";

      const actors = Array.isArray(movie.omdb?.actors) ? movie.omdb.actors.slice(0, 3) : [];

      if(!actors.length){
        block.innerHTML = `<div class="k">Актёры</div><div class="v">—</div>`;
        return block;
      }

      const k = document.createElement("div");
      k.className = "k";
      k.textContent = "Актёры";

      const v = document.createElement("div");
      v.className = "v";

      const wrap = document.createElement("div");
      wrap.className = "actorChips";

      actors.forEach(a => {
        const chip = document.createElement("span");
        chip.className = "tagChip actorChip";
        chip.innerHTML = highlightHtml(a, q);
        chip.title = "Выбрать как любимого актёра";
        chip.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          setFavoriteActorFromChip(a);
        });
        wrap.appendChild(chip);
      });

      v.appendChild(wrap);
      block.appendChild(k);
      block.appendChild(v);
      return block;
    }

    function renderRated(){
      const list = getRatedFilteredSorted();
      const q = normalize(els.search.value);

      const totalPages = Math.max(1, Math.ceil(list.length / PAGE_SIZE));
      ratedPage = clamp(ratedPage, 1, totalPages);
      const start = (ratedPage - 1) * PAGE_SIZE;
      const pageItems = list.slice(start, start + PAGE_SIZE);

      els.pageInfo.textContent = `Страница ${ratedPage} из ${totalPages}`;

      els.items.innerHTML = "";
      if(pageItems.length === 0){
        const empty = document.createElement("div");
        empty.className = "empty";
        const ratedTotal = movies.filter(m => (m.status || "watched") === "watched").length;
        if(ratedTotal === 0){
          empty.textContent = "Пока пусто. Перейди в “Оценить” и добавь первый фильм 🙂";
        }else{
          empty.innerHTML = `Ничего не найдено.<br><span style="opacity:.8">Попробуй поискать по тегам или актёрам.</span>`;
        }
        els.items.appendChild(empty);
        renderStats();
        return;
      }

      pageItems.forEach(movie => {
        const { sum, final } = computeScores(movie.scores);
        const date = new Date(movie.createdAt || Date.now());
        const dateStr = date.toLocaleString("ru-RU", { year:"numeric", month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit" });

        const statusLabel = STATUS_LABEL[movie.status] || STATUS_LABEL.watched;
        const tags = Array.isArray(movie.tags) ? movie.tags : [];
        const posterUrl = movie.omdb?.posterUrl || null;
        const isFav = !!movie.favorite;

        const details = document.createElement("details");
        details.className = "item";
        details.dataset.id = movie.id;

        // Accordion: only one card open in “Оценённые”
        details.addEventListener("toggle", () => {
          if(details.open) closeOtherOpenedDetails(els.items, details);
        });

        const summary = document.createElement("summary");

        const left = document.createElement("div");
        left.className = "sumLeft";

        const thumbEl = makeThumb(posterUrl);        left.appendChild(thumbEl);

        const text = document.createElement("div");
        text.className = "sumText";

        const titleLine = document.createElement("div");
        titleLine.className = "titleLine";

        const title = document.createElement("p");
        title.className = "title";
        title.innerHTML = highlightHtml(movie.name, q);
        titleLine.appendChild(title);

        if(movie.year){
          const yearTag = document.createElement("span");
          yearTag.className = "tagPill";
          yearTag.textContent = String(movie.year);
          titleLine.appendChild(yearTag);
        }

        // Emotional highlight: emotions >= overall + 2
        try{
          const o = clamp(Number(movie?.scores?.overall ?? 0), 0, 10);
          const e = clamp(Number(movie?.scores?.emotions ?? 0), 0, 10);
          if(e >= o + 2){
            const emoPill = document.createElement("span");
            emoPill.className = "tagPill";
            emoPill.textContent = "🔥";
            emoPill.title = "Эмоции заметно выше общего впечатления";
            titleLine.appendChild(emoPill);
          }
        }catch{}

        const statusPill = document.createElement("span");
        statusPill.className = "tagPill";
        statusPill.textContent = statusLabel;
        titleLine.appendChild(statusPill);

        if(isFav){
          const favPill = document.createElement("span");
          favPill.className = "tagPill";
          favPill.textContent = "⭐";
          titleLine.appendChild(favPill);
        }

        text.appendChild(titleLine);

        const meta = document.createElement("div");
        meta.className = "metaLine";
        meta.innerHTML = `<span class="badgeRed">${formatFinalScore(final)}</span>`;
        if(tags.length){
          meta.innerHTML += `<span class="chip">Теги: <b>${highlightHtml(tags.join(", "), q)}</b></span>`;
        }
        text.appendChild(meta);

        left.appendChild(text);

        const right = document.createElement("div");
        right.className = "sumRight";

        const actions = document.createElement("div");
        actions.className = "quickActions";

        const favBtn = document.createElement("button");
        favBtn.type = "button";
        favBtn.className = "iconBtn" + (isFav ? " favOn" : "");
        favBtn.title = isFav ? "Убрать из избранного" : "В избранное";
        favBtn.textContent = isFav ? "⭐" : "☆";
        if(movie.id === lastFavPulseId){
          favBtn.classList.add("pulse");
          favBtn.addEventListener("animationend", () => favBtn.classList.remove("pulse"), { once:true });
        }
        favBtn.addEventListener("click", (e) => {
          e.preventDefault(); e.stopPropagation();
          toggleFavorite(movie.id);
        });
        const delMini = document.createElement("button");
        delMini.type = "button";
        delMini.className = "iconBtn dangerMini";
        delMini.title = "Удалить";
        delMini.textContent = "🗑";
        delMini.addEventListener("click", (e) => {
          e.preventDefault(); e.stopPropagation();
          deleteMovieConfirm(movie.id, details);
        });

        actions.appendChild(favBtn);
                actions.appendChild(delMini);

        const arrow = document.createElement("div");
        arrow.className = "arrow";
        arrow.textContent = "▾";

        right.appendChild(actions);
        right.appendChild(arrow);

        summary.appendChild(left);
        summary.appendChild(right);

        const body = document.createElement("div");
        body.className = "itemBody";

        const posterWrap = document.createElement("div");
        posterWrap.className = "posterBig";

        const posterBox = document.createElement("div");
        posterBox.className = "posterBigImg";
        if(posterUrl){
          const img = document.createElement("img");
          img.src = posterUrl;
          img.alt = "poster";
          img.loading = "lazy";
          posterBox.appendChild(img);
        } else {
          posterBox.textContent = "Нет постера";
        }

        const posterMeta = document.createElement("div");
        posterMeta.className = "posterMeta";

        const omdb = movie.omdb || {};
        const imdbLink = omdb.imdbID ? `https://www.imdb.com/title/${encodeURIComponent(omdb.imdbID)}/` : null;

        const omdbGrid = document.createElement("div");
        omdbGrid.className = "infoGrid";

        const kvGenre = document.createElement("div");
        kvGenre.className = "kv";
        kvGenre.innerHTML = `<span>Жанры</span><b>${escapeHtml(omdb.genre || "—")}</b>`;

        const kvRuntime = document.createElement("div");
        kvRuntime.className = "kv";
        kvRuntime.innerHTML = `<span>Длительность</span><b>${escapeHtml(omdb.runtime || "—")}</b>`;

        const kvImdb = document.createElement("div");
        kvImdb.className = "kv";
        kvImdb.innerHTML = `<span>IMDb рейтинг</span><b>${escapeHtml(omdb.imdbRating || "—")}</b>`;

        const kvType = document.createElement("div");
        kvType.className = "kv";
        kvType.innerHTML = `<span>Тип</span><b>${escapeHtml(typeLabel(omdb.type))}</b>`;

        const kvImdbId = document.createElement("div");
        kvImdbId.className = "kv";
        kvImdbId.innerHTML = `<span>IMDb</span><b>${imdbLink ? `<a class="imdbLink" href="${imdbLink}" target="_blank" rel="noopener noreferrer">Открыть ↗</a>` : "—"}</b>`;

        omdbGrid.appendChild(kvGenre);
        omdbGrid.appendChild(kvRuntime);
        omdbGrid.appendChild(kvImdb);
        omdbGrid.appendChild(kvType);
        omdbGrid.appendChild(kvImdbId);

        posterMeta.appendChild(omdbGrid);
        posterWrap.appendChild(posterBox);
        posterWrap.appendChild(posterMeta);

        const infoGrid = document.createElement("div");
        infoGrid.className = "infoGrid";

        const kvDirector = document.createElement("div");
        kvDirector.className = "kv";
        kvDirector.innerHTML = `<span>Режиссёр(ы)</span><b>${movie.director ? highlightHtml(movie.director, q) : "—"}</b>`;

        const kvYear = document.createElement("div");
        kvYear.className = "kv";
        kvYear.innerHTML = `<span>Год</span><b>${escapeHtml(movie.year ?? "—")}</b>`;

        const kvStatus = document.createElement("div");
        kvStatus.className = "kv";
        kvStatus.innerHTML = `<span>Статус</span><b>${escapeHtml(statusLabel)}</b>`;

        const kvDate = document.createElement("div");
        kvDate.className = "kv";
        kvDate.innerHTML = `<span>Добавлено</span><b>${escapeHtml(dateStr)}</b>`;

        infoGrid.appendChild(kvDirector);
        infoGrid.appendChild(kvYear);
        infoGrid.appendChild(kvStatus);
        infoGrid.appendChild(kvDate);

        const scoresGrid = document.createElement("div");
        scoresGrid.className = "infoGrid";
        CRITERIA.forEach(c => {
          const kv = document.createElement("div");
          kv.className = "kv";
          const v = movie.scores?.[c.key] ?? "—";
          kv.innerHTML = `<span>${escapeHtml(c.label)}</span><b>${escapeHtml(v)}</b>`;
          scoresGrid.appendChild(kv);
        });

        const tagsBlock = document.createElement("div");
        tagsBlock.className = "textBlock";
        const tagsK = document.createElement("div");
        tagsK.className = "k";
        tagsK.textContent = "Теги";
        const tagsV = document.createElement("div");
        tagsV.className = "v";
        if(tags.length){
          const wrap = document.createElement("div");
          wrap.className = "tagLinks";
          tags.forEach(t => {
            const b = document.createElement("button");
            b.type = "button";
            b.className = "tagLink";
            b.textContent = t;
            b.title = "Фильтровать по тегу";
            b.addEventListener("click", (e) => {
              e.preventDefault(); e.stopPropagation();
              els.tagFilter.value = t;
              ratedPage = 1;
              renderRated();
            });
            wrap.appendChild(b);
          });
          tagsV.appendChild(wrap);
        }else{
          tagsV.textContent = "—";
        }
        tagsBlock.appendChild(tagsK);
        tagsBlock.appendChild(tagsV);

        const notesBlock = document.createElement("div");
        notesBlock.className = "textBlock";
        const notesK = document.createElement("div");
        notesK.className = "k";
        notesK.textContent = "Заметки";
        const notesV = document.createElement("div");
        notesV.className = "v";
        const notesText = (movie.notes || "").trim();
        if(!notesText){
          notesV.textContent = "—";
        }else{
          const notesP = document.createElement("div");
          notesP.className = "notesText notesClamp";
          notesP.textContent = notesText;
          notesV.appendChild(notesP);

          // If notes are long, show a toggle (3 lines clamp)
          const isLong = notesText.length > 180 || notesText.split(/\n/).length > 3;
          if(isLong){
            const toggle = document.createElement("button");
            toggle.type = "button";
            toggle.className = "notesToggle";
            toggle.textContent = "Развернуть";
            toggle.addEventListener("click", (e) => {
              e.preventDefault(); e.stopPropagation();
              const expanded = notesP.classList.toggle("notesExpanded");
              toggle.textContent = expanded ? "Свернуть" : "Развернуть";
            });
            notesV.appendChild(toggle);
          }else{
            // Remove clamp for short notes
            notesP.classList.remove("notesClamp");
          }
        }
        notesBlock.appendChild(notesK);
        notesBlock.appendChild(notesV);

        const actionsRow = document.createElement("div");
        actionsRow.className = "actionsRow";

        const delBtn = document.createElement("button");
        delBtn.className = "danger";
        delBtn.type = "button";
        delBtn.textContent = "Удалить";
        delBtn.addEventListener("click", (e) => {
          e.preventDefault(); e.stopPropagation();
          deleteMovieConfirm(movie.id, details);
        });

        actionsRow.appendChild(delBtn);

        body.appendChild(posterWrap);
        body.appendChild(infoGrid);
const actorsBlock = buildActorsBlock(movie, q);
        body.appendChild(actorsBlock);

        body.appendChild(scoresGrid);
        body.appendChild(tagsBlock);
        body.appendChild(notesBlock);
        body.appendChild(actionsRow);

        details.appendChild(summary);
        details.appendChild(body);

        els.items.appendChild(details);
      });

      renderStats();
    }

    function openRatedItem(id){
      const all = getRatedFilteredSorted();
      const idx = all.findIndex(m => m.id === id);
      if(idx >= 0){
        ratedPage = Math.floor(idx / PAGE_SIZE) + 1;
        renderRated();
      }
      const el = els.items.querySelector(`details.item[data-id="${CSS.escape(id)}"]`);
      if(!el) return;

      el.open = true;
      el.classList.remove("flash");
      void el.offsetWidth;
      el.classList.add("flash");

      // UX micro-accent: ping poster + score
      const p = el.querySelector(".posterBigImg");
      if(p){
        p.classList.remove("pingPoster"); void p.offsetWidth; p.classList.add("pingPoster");
      }
      const s = el.querySelector(".scorePill");
      if(s){
        s.classList.remove("pingScore"); void s.offsetWidth; s.classList.add("pingScore");
      }

      el.scrollIntoView({ behavior: "smooth", block: "start" });
    }

    function openWishItem(id, kind){
      const k = kind === "series" ? "series" : "movie";
      const listEl = k === "series" ? els.wishSeriesList : els.wishMoviesList;
      if(!listEl) return;
      const el = listEl.querySelector(`details.item[data-id="${CSS.escape(id)}"]`);
      if(!el) return;

      el.open = true;
      closeOtherOpenedDetails(listEl, el);
      el.classList.remove("flash");
      void el.offsetWidth;
      el.classList.add("flash");
      el.scrollIntoView({ behavior: "smooth", block: "start" });
    }

    // ========= Wish queue =========
    function getWishList(kind){
      const k = kind === "series" ? "series" : "movie";
      const q = normalize(k === "series" ? els.wishSeriesSearch.value : els.wishMoviesSearch.value);

      let arr = movies
        .filter(m => (m.status || "watched") === "wish")
        .filter(m => getWishKindForMovie(m) === k);

      // hide items that are currently active in “Смотрю сейчас”
      arr = arr.filter(m => !m.isNow);

      if(q) arr = arr.filter(m => movieMatchesQuery(m, q));

      arr.sort((a,b) => Number(a.queueOrder || 0) - Number(b.queueOrder || 0));
      return arr;
    }

    function pickRandomWish(kind){
      const k = kind === "series" ? "series" : "movie";
      const list = getWishList(k);
      if(list.length === 0){
        toast("Очередь пуста", "Добавь что-нибудь в “Буду смотреть”.");
        return;
      }

      const choice = list[Math.floor(Math.random() * list.length)];

      if(currentView !== "wish"){
        setWishKind(k);
        goTo("wish");
      }else if(wishKindActive !== k){
        setWishKind(k);
      }else{
        renderWishKind(k);
      }

      requestAnimationFrame(() => openWishItem(choice.id, k));
      toast("Случайный выбор", choice.name || "Без названия");
    }

    function updateWishOrderFromDOM(kind){
      const k = kind === "series" ? "series" : "movie";
      const container = k === "series" ? els.wishSeriesList : els.wishMoviesList;
      const ids = Array.from(container.querySelectorAll("details.item")).map(el => el.dataset.id);

      let order = 1;
      ids.forEach(id => {
        const m = movies.find(x => x.id === id);
        if(!m) return;
        if((m.status || "watched") !== "wish") return;
        if(getWishKindForMovie(m) !== k) return;
        m.queueOrder = order++;
      });

      saveMovies();
    }

    function getDragAfterElement(container, y){
      const candidates = Array.from(container.querySelectorAll("details.item:not(.dragging)"));
      let closest = { offset: Number.NEGATIVE_INFINITY, element: null };

      candidates.forEach(child => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if(offset < 0 && offset > closest.offset){
          closest = { offset, element: child };
        }
      });

      return closest.element;
    }

    function renderWishKind(kind){
      const k = kind === "series" ? "series" : "movie";
      const q = normalize(k === "series" ? els.wishSeriesSearch.value : els.wishMoviesSearch.value);
      const list = getWishList(k);

      const listEl  = k === "series" ? els.wishSeriesList  : els.wishMoviesList;
      const statsEl = k === "series" ? els.wishSeriesStats : els.wishMoviesStats;

      listEl.innerHTML = "";

      if(list.length === 0){
        listEl.innerHTML = `<div class="empty">Очередь пуста. Добавь что-нибудь из “Оценить”.</div>`;
        statsEl.textContent = "В очереди: 0";
        return;
      }

      statsEl.textContent = `В очереди: ${list.length}`;

      list.forEach((movie, index) => {
        const date = new Date(movie.createdAt || Date.now());
        const dateStr = date.toLocaleString("ru-RU", { year:"numeric", month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit" });

        const statusLabel = STATUS_LABEL[movie.status] || STATUS_LABEL.watched;
        const tags = Array.isArray(movie.tags) ? movie.tags : [];
        const posterUrl = movie.omdb?.posterUrl || null;
        const isFav = !!movie.favorite;

        const details = document.createElement("details");
        details.className = "item";
        details.dataset.id = movie.id;

        // Accordion: only one card open in “Буду смотреть”
        details.addEventListener("toggle", () => {
          if(document.body.classList.contains("dragMode")) return;
          if(details.open) closeOtherOpenedDetails(listEl, details);
        });

        // drag & drop
        // drag & drop (handle only)
details.draggable = false;

// Lightweight placeholder-based sorting (prevents flicker with <details>)
function ensurePlaceholder(){
  if(dragPlaceholder) return dragPlaceholder;
  dragPlaceholder = document.createElement("div");
  dragPlaceholder.className = "dropPlaceholder";
  dragPlaceholder.setAttribute("aria-hidden", "true");
  return dragPlaceholder;
}

function setDragMode(on){
  document.body.classList.toggle("dragMode", !!on);
}

function beginDrag(e){
  dragId = movie.id;
  setDragMode(true);

  // Close expanded card while dragging to avoid height transitions
  details.open = false;

  details.classList.add("dragging");

  // Create/size placeholder and place it right after the dragged card
  const ph = ensurePlaceholder();
  const rect = details.getBoundingClientRect();
  ph.style.height = Math.max(56, Math.round(rect.height)) + "px";
  ph.style.marginTop = "0px";
  ph.style.marginBottom = "0px";

  // Insert placeholder near dragged item (if not already in this list)
  if(ph.parentNode !== listEl){
    ph.remove();
    listEl.insertBefore(ph, details.nextSibling);
  } else {
    // keep it near the item at start
    listEl.insertBefore(ph, details.nextSibling);
  }

  dragLastPlaceholderBeforeId = null;

  // Use tiny transparent drag image so the browser doesn't snapshot the whole card
  try{
    const img = new Image();
    img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMB/axv1sQAAAAASUVORK5CYII=";
    e.dataTransfer.setDragImage(img, 0, 0);
  }catch{}
  try{ e.dataTransfer.setData("text/plain", movie.id); }catch{}
  try{ e.dataTransfer.effectAllowed = "move"; }catch{}
}

function finalizeDrag(){
  details.classList.remove("dragging");
  dragId = null;
  setDragMode(false);

  // Put dragged card where the placeholder is
  if(dragPlaceholder && dragPlaceholder.parentNode === listEl){
    listEl.insertBefore(details, dragPlaceholder);
    dragPlaceholder.remove();
  }

  dragPlaceholder = null;
  dragLastPlaceholderBeforeId = null;

  // Save order based on DOM and refresh pills (no full rerender)
  updateWishOrderFromDOM(k);
  updateWishOrderPillsInDOM(listEl);

  toast("Порядок сохранён");
}

function endDrag(){
  finalizeDrag();
}

        const summary = document.createElement("summary");

// Prevent <details> toggle while dragging (keeps UI stable)
summary.addEventListener("click", (e) => {
  if(document.body.classList.contains("dragMode")){
    e.preventDefault();
    e.stopPropagation();
  }
}, true);


        const left = document.createElement("div");
        left.className = "sumLeft";
        const thumbEl = makeThumb(posterUrl);        left.appendChild(thumbEl);

        const text = document.createElement("div");
        text.className = "sumText";

        const titleLine = document.createElement("div");
        titleLine.className = "titleLine";

        const title = document.createElement("p");
        title.className = "title";
        title.innerHTML = highlightHtml(movie.name, q);
        titleLine.appendChild(title);

        const statusPill = document.createElement("span");
        statusPill.className = "tagPill";
        statusPill.textContent = statusLabel;
        titleLine.appendChild(statusPill);

        const orderPill = document.createElement("span");
        orderPill.className = "chip orderPill";
        orderPill.textContent = "№" + (index + 1);
        titleLine.appendChild(orderPill);

        if(isFav){
          const favPill = document.createElement("span");
          favPill.className = "tagPill";
          favPill.textContent = "⭐";
          titleLine.appendChild(favPill);
        }

        text.appendChild(titleLine);


const meta = document.createElement("div");
meta.className = "metaLine";

// Tags (clickable)
if(tags.length){
  const tagsWrap = document.createElement("div");
  tagsWrap.className = "tagsInline";
  tags.forEach(t => {
    const b = document.createElement("button");
    b.type = "button";
    b.className = "tagChip";
    b.innerHTML = highlightHtml(t, q);
    b.addEventListener("click", (e) => {
      e.preventDefault(); e.stopPropagation();
      // apply tag filter in rated (and as search hint in wish)
      els.tagFilter.value = t;
      goTo("rated");
      ratedPage = 1;
      renderRated();
      toast("Фильтр по тегу", t);
    });
    tagsWrap.appendChild(b);
  });
  meta.appendChild(tagsWrap);
}

// Queue age + stale marker
const ageTxt = formatQueueAge(movie.createdAt);
const ageChip = document.createElement("span");
ageChip.className = "chip";
ageChip.textContent = ageTxt;
meta.appendChild(ageChip);

if(isQueueStale(movie.createdAt)){
  const stale = document.createElement("span");
  stale.className = "stalePill";
  stale.textContent = "Давно в очереди";
  meta.appendChild(stale);
}

// Reason (short) in summary if present
const reason = (movie.wishReason || "").trim();
if(reason){
  const r = document.createElement("span");
  r.className = "chip reasonChip";
  r.textContent = "Почему: " + reason;
  meta.appendChild(r);
}

text.appendChild(meta);

        left.appendChild(text);

        const right = document.createElement("div");
        right.className = "sumRight";

        const actions = document.createElement("div");
        actions.className = "quickActions";

        const favBtn = document.createElement("button");
        favBtn.type = "button";
        favBtn.className = "iconBtn" + (isFav ? " favOn" : "");
        favBtn.title = isFav ? "Убрать из избранного" : "В избранное";
        favBtn.textContent = "★";
        favBtn.addEventListener("click", (e) => {
          e.preventDefault(); e.stopPropagation();
          toggleFavorite(movie.id);
        });
        actions.appendChild(favBtn);

        const toRatedBtn = document.createElement("button");
        toRatedBtn.type = "button";
        toRatedBtn.className = "iconBtn";
        toRatedBtn.title = "Переместить в оценённые";
        toRatedBtn.textContent = "✓";
        toRatedBtn.addEventListener("click", (e) => {
          e.preventDefault(); e.stopPropagation();

          // UX: fade the card out first, then move
          details.classList.add("leaving");
          setTimeout(() => {
            movie.status = "watched";
            movie.queueOrder = null;
            saveMovies();
            renderEverything();
            toast("Перемещено в оценённые", movie.name || "Без названия");
            goTo("rated", { openId: movie.id });
          }, 170);
        });
        actions.appendChild(toRatedBtn);

        // kino.pub search button (opens in new tab)
        const kinoUrl = kinoPubSearchUrl(movie, k);
        if(kinoUrl){
          const kinoBtn = document.createElement("button");
          kinoBtn.type = "button";
          kinoBtn.className = "iconBtn kinoBtn";
          kinoBtn.textContent = "KP";
          kinoBtn.title = "Искать на kino.pub";
          kinoBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            window.open(kinoUrl, "_blank", "noopener,noreferrer");
          });
          actions.appendChild(kinoBtn);
        }


        const delMini = document.createElement("button");
        delMini.type = "button";
        delMini.className = "iconBtn dangerMini";
        delMini.title = "Удалить";
        delMini.textContent = "🗑";
        delMini.addEventListener("click", (e) => {
          e.preventDefault(); e.stopPropagation();
          deleteMovieConfirm(movie.id, details);
        });
        actions.appendChild(delMini);

        const handle = document.createElement("div");
        handle.className = "dragHandle";
        handle.textContent = "≡";
        handle.title = "Перетащить";
        handle.draggable = true;
        handle.addEventListener("dragstart", beginDrag);
        handle.addEventListener("dragend", endDrag);

        right.appendChild(actions);
        right.appendChild(handle);

        summary.appendChild(left);
        summary.appendChild(right);

        details.appendChild(summary);

        
        const body = document.createElement("div");
        body.className = "itemBody";

        const posterWrap = document.createElement("div");
        posterWrap.className = "posterBig";

        const posterBox = document.createElement("div");
        posterBox.className = "posterBigImg";
        if(posterUrl){
          const img = document.createElement("img");
          img.src = posterUrl;
          img.alt = "poster";
          img.loading = "lazy";
          posterBox.appendChild(img);
        } else {
          posterBox.textContent = "Нет постера";
        }

        const posterMeta = document.createElement("div");
        posterMeta.className = "posterMeta";

        const omdb = movie.omdb || {};
        const imdbLink = omdb.imdbID ? `https://www.imdb.com/title/${encodeURIComponent(omdb.imdbID)}/` : null;
        const kindLabel = getWishKindForMovie(movie) === "series" ? "Сериал" : "Фильм";

        const omdbGrid = document.createElement("div");
        omdbGrid.className = "infoGrid";

        const kvGenre = document.createElement("div");
        kvGenre.className = "kv";
        kvGenre.innerHTML = `<span>Жанры</span><b>${escapeHtml(omdb.genre || "—")}</b>`;

        const kvRuntime = document.createElement("div");
        kvRuntime.className = "kv";
        kvRuntime.innerHTML = `<span>Длительность</span><b>${escapeHtml(omdb.runtime || "—")}</b>`;

        const kvImdb = document.createElement("div");
        kvImdb.className = "kv";
        kvImdb.innerHTML = `<span>IMDb рейтинг</span><b>${escapeHtml(omdb.imdbRating || "—")}</b>`;

        const kvType = document.createElement("div");
        kvType.className = "kv";
        kvType.innerHTML = `<span>Тип</span><b>${escapeHtml(kindLabel)}</b>`;

        const kvImdbId = document.createElement("div");
        kvImdbId.className = "kv";
        kvImdbId.innerHTML = `<span>IMDb</span><b>${imdbLink ? `<a class="imdbLink" href="${imdbLink}" target="_blank" rel="noopener noreferrer">Открыть ↗</a>` : "—"}</b>`;

        omdbGrid.appendChild(kvGenre);
        omdbGrid.appendChild(kvRuntime);
        omdbGrid.appendChild(kvImdb);
        omdbGrid.appendChild(kvType);
        omdbGrid.appendChild(kvImdbId);

        posterMeta.appendChild(omdbGrid);

        posterWrap.appendChild(posterBox);
        posterWrap.appendChild(posterMeta);

        body.appendChild(posterWrap);

        const infoGrid = document.createElement("div");
        infoGrid.className = "infoGrid";

        const kvDirector = document.createElement("div");
        kvDirector.className = "kv";
        kvDirector.innerHTML = `<span>Режиссёр(ы)</span><b>${movie.director ? highlightHtml(movie.director, q) : "—"}</b>`;

        const kvYear = document.createElement("div");
        kvYear.className = "kv";
        kvYear.innerHTML = `<span>Год</span><b>${escapeHtml(movie.year ?? "—")}</b>`;

        const kvOrder = document.createElement("div");
        kvOrder.className = "kv";
        kvOrder.innerHTML = `<span>Очередь</span><b>№${index + 1}</b>`;

        const kvDate = document.createElement("div");
        kvDate.className = "kv";
        kvDate.innerHTML = `<span>Добавлено</span><b>${escapeHtml(dateStr)}</b>`;

        infoGrid.appendChild(kvDirector);
        infoGrid.appendChild(kvYear);
        infoGrid.appendChild(kvOrder);
        infoGrid.appendChild(kvDate);

        body.appendChild(infoGrid);

        // actors (first 3) as chips (clickable)
        if(typeof buildActorsBlock === "function"){
          body.appendChild(buildActorsBlock(movie, q));
        }
        // tags & notes blocks
        const tagsBlock = document.createElement("div");
        tagsBlock.className = "textBlock";
        tagsBlock.innerHTML = `<div class="k">Теги</div><div class="v">${tags.length ? escapeHtml(tags.join(", ")) : "—"}</div>`;

        const notes = (movie.notes || "").trim();
        const notesBlock = document.createElement("div");
        notesBlock.className = "textBlock";
        notesBlock.innerHTML = `<div class="k">Заметки</div><div class="v">${notes ? escapeHtml(notes) : "—"}</div>`;

        body.appendChild(tagsBlock);
        body.appendChild(notesBlock);

        const actionsRow = document.createElement("div");
        actionsRow.className = "actionsRow";

        const delBtn = document.createElement("button");
        delBtn.type = "button";
        delBtn.className = "danger";
        delBtn.textContent = "Удалить";
        delBtn.addEventListener("click", (e) => {
          e.preventDefault(); e.stopPropagation();
          deleteMovieConfirm(movie.id, details);
        });

        actionsRow.appendChild(delBtn);
        
        // Reason: why want to watch (Wish only)
        const reasonBlock = document.createElement("div");
        reasonBlock.className = "textBlock";
        reasonBlock.innerHTML = `
          <div class="k">Почему хочу посмотреть</div>
          <div class="v">
            <input class="reasonInput" type="text" list="reasonSuggestions" placeholder="Напр.: советовали / люблю такие сюжеты / из-за актёра" value="${escapeHtml((movie.wishReason || '').trim())}">
          </div>
        `;

        const reasonInput = reasonBlock.querySelector(".reasonInput");
        reasonInput.addEventListener("input", () => {
          movie.wishReason = reasonInput.value;
          saveMovies();

          // Update summary chip without rerender
          const existing = details.querySelector(".reasonChip");
          const v = (movie.wishReason || "").trim();
          if(v){
            if(existing) existing.textContent = "Почему: " + v;
            else {
              const r = document.createElement("span");
              r.className = "chip reasonChip";
              r.textContent = "Почему: " + v;
              const metaLine = details.querySelector(".metaLine");
              if(metaLine) metaLine.appendChild(r);
            }
          } else {
            if(existing) existing.remove();
          }
        });

        body.appendChild(reasonBlock);

body.appendChild(actionsRow);

        details.appendChild(body);
        listEl.appendChild(details);
      });

      // enable drag sorting behavior on the list container (once per list)
      if(!listEl._dragoverBound){
        listEl._dragoverBound = true;

        listEl.addEventListener("dragover", (e) => {
        e.preventDefault();

        // Throttle DOM work to animation frames to avoid jank on weak devices
        if(!listEl._dragRAF){
          listEl._dragRAF = 0;
          listEl._lastDragY = 0;
        }
        listEl._lastDragY = e.clientY;

        if(listEl._dragRAF) return;
        listEl._dragRAF = requestAnimationFrame(() => {
          listEl._dragRAF = 0;

          // We sort using the placeholder; the real card stays "dragging"
          const dragging = listEl.querySelector("details.item.dragging");
          if(!dragging) return;

          autoScrollDuringDrag(listEl._lastDragY);

          const ph = dragPlaceholder;
          if(!ph || ph.parentNode !== listEl) return;

          const afterEl = getDragAfterElement(listEl, listEl._lastDragY);

          // Avoid pointless re-inserts (helps stability)
          const beforeId = afterEl ? afterEl.dataset.id : "__END__";
          if(beforeId === dragLastPlaceholderBeforeId) return;
          dragLastPlaceholderBeforeId = beforeId;

          if(afterEl == null) listEl.appendChild(ph);
          else listEl.insertBefore(ph, afterEl);
        });
      }, { passive: false });

      listEl.addEventListener("drop", (e) => {
        e.preventDefault();
        // dragend will also fire, but drop makes it feel snappier in some browsers
        const dragging = listEl.querySelector("details.item.dragging");
        if(dragging) finalizeDrag();
      }, { passive: false });
      }
    }

    function renderWishMovies(){ renderWishKind("movie"); }
    
    // ========= Now Watching (Смотрю сейчас) =========
    async function ensureEpisodesForNow(){
      if(!nowState.imdbID) return;
      if(omdbEpCache[nowState.imdbID]?.seasons) return;

      omdbEpCache[nowState.imdbID] = omdbEpCache[nowState.imdbID] || {};
      const entry = omdbEpCache[nowState.imdbID];

      // fetch series details to get totalSeasons (if not set)
      try{
        const d = await omdbFetch({ i: nowState.imdbID, plot:"short" });
        if(d.Response === "True"){
          const ts = Number(d.totalSeasons || 0) || null;
          entry.totalSeasons = ts;
          if(!nowState.totalSeasons && ts) nowState.totalSeasons = ts;
          if(!nowState.runtimeMin){
            const rm = parseRuntimeMinutes(d.Runtime);
            if(rm) nowState.runtimeMin = rm;
          }
          if(!nowState.posterUrl && d.Poster && d.Poster !== "N/A") nowState.posterUrl = d.Poster;
          if(!nowState.title && d.Title && d.Title !== "N/A") nowState.title = d.Title;
        }
      }catch{}

      const totalSeasons = Number(entry.totalSeasons || nowState.totalSeasons || 0) || 0;
      if(!totalSeasons){
        // no seasons info — keep empty
        entry.seasons = entry.seasons || {};
        saveEpCache();
        saveNowState();
        return;
      }

      entry.seasons = entry.seasons || {};
      let totalEpisodes = 0;

      // Fetch each season list (lightweight; OMDb returns Episodes array)
      for(let s=1; s<=totalSeasons; s++){
        if(entry.seasons[String(s)]) { totalEpisodes += entry.seasons[String(s)].length; continue; }
        try{
          const seasonData = await omdbFetch({ i: nowState.imdbID, Season: s });
          if(seasonData.Response === "True" && Array.isArray(seasonData.Episodes)){
            // Normalize: keep only fields we need
            entry.seasons[String(s)] = seasonData.Episodes.map(ep => ({
              Episode: String(ep.Episode || ""),
              Title: String(ep.Title || ""),
              Released: String(ep.Released || ""),
              imdbRating: String(ep.imdbRating || ""),
              imdbID: String(ep.imdbID || "")
            }));
            totalEpisodes += entry.seasons[String(s)].length;
          }else{
            entry.seasons[String(s)] = [];
          }
        }catch{
          entry.seasons[String(s)] = [];
        }
      }

      entry.totalEpisodes = totalEpisodes || null;
      saveEpCache();
      saveNowState();
    }

    function renderNowHomeWidget(){
      if(!els.nowWidgetHome) return;

      if(!nowState.imdbID){
        els.nowWidgetHome.innerHTML = "";
        return;
      }

      const { watched, total, pct } = computeNowProgress();
      const next = getNextUnwatched();
      const miniStatsHtml = buildNowMiniStatsHtml(watched, total);

      const card = document.createElement("div");
      card.className = "card";
      card.style.marginTop = "12px";

      const w = document.createElement("div");
      w.className = "nowWidget";

      const poster = document.createElement("div");
      poster.className = "posterSm";
      poster.style.width = "74px";
      poster.style.height = "110px";
      if(nowState.posterUrl){
        const img = document.createElement("img");
        img.src = nowState.posterUrl;
        img.alt = "poster";
        img.loading = "lazy";
        poster.appendChild(img);
      }else poster.textContent = "—";

      const main = document.createElement("div");
      main.className = "nowWidgetMain";

      const head = document.createElement("div");
      head.className = "nowWidgetHead";
      head.innerHTML = `
        <div style="min-width:0">
          <p class="nowTitle">Смотрю сейчас: ${escapeHtml(nowState.title || "Сериал")}</p>
          <div class="nowSub">${total ? `Прогресс: ${watched}/${total} (${pct ?? 0}%)` : `Отмечено серий: ${watched}`}</div>
          ${miniStatsHtml}
        </div>
        <div class="btns" style="justify-content:flex-end">
          <button type="button" id="nowOpenBtn">Открыть</button>
          <button type="button" class="primary" id="nowNextBtn"${next ? "" : " disabled"}>Следующая серия</button>
        </div>
      `;
      const bar = document.createElement("div");
      bar.className = "progressBar";
      const fill = document.createElement("div");
      fill.style.width = (pct === null ? "0%" : String(pct) + "%");
      bar.appendChild(fill);

      main.appendChild(head);
      main.appendChild(bar);

      w.appendChild(poster);
      w.appendChild(main);
      card.appendChild(w);

      els.nowWidgetHome.innerHTML = "";
      els.nowWidgetHome.appendChild(card);

      card.querySelector("#nowOpenBtn").addEventListener("click", () => goTo("now"));
      card.querySelector("#nowNextBtn").addEventListener("click", () => {
        const n = getNextUnwatched();
        if(!n) return;
        const key = `S${n.season}E${n.episode}`;
        nowState.watched[key] = true;
        markActivityToday();
        recordWatch(1);
        saveNowState();
        renderNowHomeWidget();
        toast("Отмечено", `S${n.season}E${n.episode} • ${n.title || "серия"}`);
      });
    }
    function updateNowAddDeleteUI(){
      if(els.nowAddControls) els.nowAddControls.classList.toggle("hidden", !!nowState.imdbID);
      if(els.nowDeleteControls) els.nowDeleteControls.classList.toggle("hidden", !nowState.imdbID);
    }

    function clearActiveNowSeries(){
      // return source item back to queue (if it was hidden as active)
      try{
        if(nowState.sourceMovieId){
          const src = movies.find(x => x.id === nowState.sourceMovieId);
          if(src){ src.isNow = false; }
          saveMovies();
        }
      }catch{}

      nowState.sourceMovieId = null;
      nowState.finishPromptedFor = null;
      nowState.finishDismissedFor = null;
      nowState.imdbID = null;
      nowState.title = "";
      nowState.posterUrl = null;
      nowState.startedAt = null;
      nowState.totalSeasons = null;
      nowState.watched = {};
      saveNowState();
      updateNowAddDeleteUI();
      renderNowHomeWidget();
      renderNow();
    }


    function renderNow(){
      if(els.nowPick){ els.nowPick.value = nowState.title || ""; }
      updateNowAddDeleteUI();
      if(!els.nowCard) return;

      // top stats
      const week = sumMinutesLast7Days();
      const streak = computeStreak();
      const parts = [];
      if(week.eps || week.minutes) parts.push(`За 7 дней: ${week.eps} серий / ${formatMinutes(week.minutes)}`);
      if(nowState.streakOn) parts.push(`Стрик: ${streak} дн.`);
      if(nowState.goalEps > 0) parts.push(`Цель недели: ${nowState.goalEps} серий`);
      els.nowStatsTop.textContent = parts.join(" • ");

      // next episode banner
      const nb = document.getElementById("nowNextBanner");
      if(nb){
        const nxt = getNextUnwatched();
        if(nxt){
          const code = `S${String(nxt.season).padStart(2,"0")}E${String(nxt.episode).padStart(2,"0")}`;
          const title = nxt.title ? (" — " + nxt.title) : "";
          nb.textContent = `Следующая: ${code}${title}`;
          nb.classList.remove("hidden");
          const go = () => openNowEpisode(nxt.season, nxt.episode);
          nb.onclick = go;
          nb.onkeydown = (e)=>{ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); go(); } };
        }else{
          nb.textContent = "";
          nb.classList.add("hidden");
          nb.onclick = null;
          nb.onkeydown = null;
        }
      }


      
      // finished prompt (smart queue)
      const fp = document.getElementById("nowFinishedPrompt");
      if(fp){
        const entry = nowState.imdbID ? omdbEpCache[nowState.imdbID] : null;
        const hasEpisodes = !!(entry && entry.seasons && Object.keys(entry.seasons).length);
        const nxt2 = getNextUnwatched();
        const finished = hasEpisodes && !nxt2;
        const dismissed = nowState.finishDismissedFor === nowState.imdbID;

        // mark that we reached "finished" for this imdbID
        if(finished && nowState.finishPromptedFor !== nowState.imdbID){
          nowState.finishPromptedFor = nowState.imdbID;
          nowState.finishDismissedFor = null;
          saveNowState();
          launchConfetti();
        }

        fp.classList.toggle("hidden", !finished || dismissed);
      }

if(!nowState.imdbID){
        els.nowCard.innerHTML = `<div class="nowEmpty">Пока ничего не выбрано. Активируй сериал сверху — и здесь появятся сезоны/серии.</div>`;
        return;
      }

      // ensure episodes (async) but render skeleton fast
      els.nowCard.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.className = "posterBig";

      const posterBox = document.createElement("div");
      posterBox.className = "posterBigImg";
      posterBox.style.width = "180px";
      posterBox.style.height = "270px";
      if(nowState.posterUrl){
        const img = document.createElement("img");
        img.src = nowState.posterUrl;
        img.alt = "poster";
        img.loading = "lazy";
        posterBox.appendChild(img);
      }else posterBox.textContent = "Нет постера";

      const meta = document.createElement("div");
      meta.className = "posterMeta";

      const { watched, total, pct } = computeNowProgress();
      const next = getNextUnwatched();
      const miniStatsHtml = buildNowMiniStatsHtml(watched, total);

      const head = document.createElement("div");
      head.className = "nowWidgetHead";
      head.innerHTML = `
        <div style="min-width:0">
          <p class="nowTitle">${escapeHtml(nowState.title || "Сериал")}</p>
          <div class="nowSub">${total ? `Прогресс: ${watched}/${total} (${pct ?? 0}%)` : `Отмечено серий: ${watched}`}</div>
          ${miniStatsHtml}
        </div>
        <div class="btns" style="justify-content:flex-end">
          <button type="button" id="nowResetBtn" class="danger">Сбросить</button>
        </div>
      `;

      const bar = document.createElement("div");
      bar.className = "progressBar";
      const fill = document.createElement("div");
      fill.style.width = (pct === null ? "0%" : String(pct) + "%");
      bar.appendChild(fill);

      const controls = document.createElement("div");
      controls.className = "sessionRow";
      controls.innerHTML = `
        <div class="inline" style="gap:10px;">
          <label class="small" style="margin:0;">Мин/серия</label>
          <input id="nowRuntime" type="number" min="1" max="400" style="width:110px;" value="${escapeHtml(nowState.runtimeMin ?? "")}" placeholder="45" />
          <label class="small" style="margin:0;">Стрик</label>
          <input id="nowStreakOn" type="checkbox" ${nowState.streakOn ? "checked" : ""} />
          <label class="small" style="margin:0;">Цель недели (серий)</label>
          <input id="nowGoal" type="number" min="0" max="99" style="width:110px;" value="${escapeHtml(nowState.goalEps ?? 0)}" />
        </div>
        <div class="btns" style="justify-content:flex-end;">
          <button type="button" class="primary" id="nowNextBtn"${next ? "" : " disabled"}>Следующая серия</button>
        </div>
      `;

      meta.appendChild(head);
      meta.appendChild(bar);
      meta.appendChild(controls);

      wrap.appendChild(posterBox);
      wrap.appendChild(meta);

      els.nowCard.appendChild(wrap);

      const episodesHost = document.createElement("div");
      episodesHost.id = "nowEpisodes";
      episodesHost.className = "episodeGrid";
      episodesHost.innerHTML = `<div class="small" style="color:var(--muted);">Загружаю список серий…</div>`;
      els.nowCard.appendChild(episodesHost);

      // events
      els.nowCard.querySelector("#nowRuntime").addEventListener("input", (e) => {
        const v = Number(e.target.value || 0) || null;
        nowState.runtimeMin = v ? clamp(v,1,400) : null;
        saveNowState();
      });
      els.nowCard.querySelector("#nowStreakOn").addEventListener("change", (e) => {
        nowState.streakOn = !!e.target.checked;
        saveNowState();
        renderNow();
      });
      els.nowCard.querySelector("#nowGoal").addEventListener("input", (e) => {
        const v = Number(e.target.value || 0) || 0;
        nowState.goalEps = clamp(v,0,99);
        saveNowState();
        renderNow();
      });

      els.nowCard.querySelector("#nowResetBtn").addEventListener("click", () => {
        if(!confirm("Сбросить прогресс по сериалу? (галочки, цель и стрик)")) return;
        nowState.watched = {};
        nowState.watchLog = [];
        nowState.activityDays = [];
        saveNowState();
        renderNow();
        renderNowHomeWidget();
        toast("Прогресс сброшен");
      });

      els.nowCard.querySelector("#nowNextBtn").addEventListener("click", () => {
        const n = getNextUnwatched();
        if(!n) return;
        const key = `S${n.season}E${n.episode}`;
        nowState.watched[key] = true;
        markActivityToday();
        recordWatch(1);
        saveNowState();
        renderNow();
        renderNowHomeWidget();
        toast("Отмечено", `S${n.season}E${n.episode} • ${n.title || "серия"}`);
      });

      // async fill episodes
      (async () => {
        await ensureEpisodesForNow();
        renderNowEpisodes();
      })();
    }

    
    function openNowEpisode(season, episode){
      const s = Number(season)||0;
      const e = Number(episode)||0;
      if(!s || !e) return;

      // ensure episodes are rendered
      const host = document.getElementById("nowEpisodes");
      if(!host) return;

      // open season block
      const block = host.querySelector(`.seasonBlock[data-season="${s}"]`);
      if(block) block.classList.add("open");

      // focus episode row
      const key = `S${s}E${e}`;
      const row = host.querySelector(`.epRow[data-key="${key}"]`);
      if(row){
        host.querySelectorAll(".epRow.focusNext").forEach(el=>el.classList.remove("focusNext"));
        row.classList.add("focusNext");
        row.scrollIntoView({ behavior: "smooth", block: "center" });
        // auto remove highlight
        window.clearTimeout(openNowEpisode._t);
        openNowEpisode._t = window.setTimeout(()=>{ row.classList.remove("focusNext"); }, 2500);
      }
    }

    function renderNowEpisodes(){
      const host = document.getElementById("nowEpisodes");
      if(!host) return;

      host.innerHTML = "";
      if(!nowState.imdbID){
        host.innerHTML = "";
        return;
      }

      const entry = omdbEpCache[nowState.imdbID];
      const seasonsObj = entry?.seasons || {};
      const seasons = Object.keys(seasonsObj).map(n=>Number(n)).filter(n=>n>0).sort((a,b)=>a-b);

      if(!seasons.length){
        host.innerHTML = `<div class="small" style="color:var(--muted);">Не удалось получить список серий из OMDb. Можно продолжать отмечать “Следующую серию” и вести прогресс, но без списка.</div>`;
        return;
      }

      for(const s of seasons){
        const eps = seasonsObj[String(s)] || [];
        const block = document.createElement("div");
        block.className = "seasonBlock";
        block.dataset.season = String(s);
        block.classList.toggle("open", false);

        const seasonWatched = eps.filter(ep => nowState.watched[`S${s}E${ep.Episode}`]).length;
        const seasonHead = document.createElement("div");
        seasonHead.className = "seasonHead";
        seasonHead.innerHTML = `<b>Сезон ${s}</b><span class="chip">${seasonWatched}/${eps.length || 0}</span>`;
        seasonHead.addEventListener("click", () => block.classList.toggle("open"));
        block.appendChild(seasonHead);

        const body = document.createElement("div");
        body.className = "seasonBody";

        eps.forEach(ep => {
          const key = `S${s}E${ep.Episode}`;
          const row = document.createElement("div");
          row.className = "epRow";
          row.dataset.key = key;

          const left = document.createElement("div");
          left.className = "epLeft";

          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.checked = !!nowState.watched[key];

          const meta = document.createElement("div");
          meta.className = "epMeta";

          const t = document.createElement("p");
          t.className = "epTitle";
          t.textContent = `E${ep.Episode} • ${ep.Title || "Серия"}`;

          const sub = document.createElement("div");
          sub.className = "epSub";
          const rel = ep.Released && ep.Released !== "N/A" ? ep.Released : "";
          const ir = ep.imdbRating && ep.imdbRating !== "N/A" ? ("IMDb: " + ep.imdbRating) : "";
          sub.textContent = [rel, ir].filter(Boolean).join(" • ") || "—";

          meta.appendChild(t);
          meta.appendChild(sub);

          left.appendChild(cb);
          left.appendChild(meta);

          const badge = document.createElement("div");
          badge.className = "epBadge";
          badge.textContent = cb.checked ? "Просмотрено" : "—";

          cb.addEventListener("change", () => {
            nowState.watched[key] = !!cb.checked;
            if(cb.checked){
              markActivityToday();
              recordWatch(1);
            }
            saveNowState();
            badge.textContent = cb.checked ? "Просмотрено" : "—";
            // update totals & UI
            renderNowHomeWidget();
            // update season head counts + top stats without full rerender
            renderNow();
          });

          row.appendChild(left);
          row.appendChild(badge);
          body.appendChild(row);
        });

        block.appendChild(body);
        host.appendChild(block);
      }

      // refresh next banner after episodes render
      const nb = document.getElementById("nowNextBanner");
      if(nb){
        const nxt = getNextUnwatched();
        if(nxt){
          const code = `S${String(nxt.season).padStart(2,"0")}E${String(nxt.episode).padStart(2,"0")}`;
          const title = nxt.title ? (" — " + nxt.title) : "";
          nb.textContent = `Следующая: ${code}${title}`;
          nb.classList.remove("hidden");
        }else{
          nb.textContent = "";
          nb.classList.add("hidden");
        }
      }

    }

    function formatMinutes(min){
      const m = Number(min || 0) || 0;
      if(m <= 0) return "0м";
      const h = Math.floor(m / 60);
      const mm = m % 60;
      if(!h) return `${mm}м`;
      if(!mm) return `${h}ч`;
      return `${h}ч ${mm}м`;
    }

    // Now pick: simple free text (works with OMDb if the title exists in library)
    function findSeriesCandidateByName(name){
      const nn = normalize(name);
      if(!nn) return null;
      // prefer wish series, then rated series
      const wishSeries = movies.filter(m => (m.status||"watched")==="wish" && getWishKindForMovie(m)==="series");
      const ratedSeries = movies.filter(m => (m.status||"watched")==="watched" && getWishKindForMovie(m)==="series");
      const all = wishSeries.concat(ratedSeries);
      return all.find(m => normalize(m.name) === nn) || null;
    }


    async function applyNowFromOmdbTitle(title){
      const q = String(title || "").trim();
      if(!q) return false;

      // 1) Try exact title -> series
      try{
        let d = await omdbFetch({ t: q, type: "series", plot:"short" });
        if(d && d.Response === "True" && String(d.Type||"").toLowerCase() === "series"){
          applyNowFromOmdbDetails(d);
          return true;
        }

        // 2) Fallback: search list -> first series
        const sData = await omdbFetch({ s: q, type: "series" });
        if(sData && sData.Response === "True" && Array.isArray(sData.Search) && sData.Search.length){
          const first = sData.Search.find(x => String(x.Type||"").toLowerCase() === "series") || sData.Search[0];
          if(first && first.imdbID){
            d = await omdbFetch({ i: first.imdbID, plot:"short" });
            if(d && d.Response === "True" && String(d.Type||"").toLowerCase() === "series"){
              applyNowFromOmdbDetails(d);
              return true;
            }
          }
        }
      }catch(e){
        // handled by caller
      }
      return false;
    }

    function applyNowFromOmdbDetails(d){
      // Reset progress for a new active series
      nowState.imdbID = (d.imdbID && d.imdbID !== "N/A") ? d.imdbID : null;
      nowState.title = (d.Title && d.Title !== "N/A") ? d.Title : (nowState.title || "");
      nowState.posterUrl = (d.Poster && d.Poster !== "N/A") ? d.Poster : null;
      nowState.startedAt = Date.now();
      nowState.runtimeMin = parseRuntimeMinutes(d.Runtime) || nowState.runtimeMin || null;
      nowState.totalSeasons = Number(d.totalSeasons || 0) || null;

      nowState.watched = {};
      nowState.watchLog = [];
        nowState.activityDays = [];

      // seed cache entry (episodes will be fetched lazily in ensureEpisodesForNow)
      if(nowState.imdbID){
        omdbEpCache[nowState.imdbID] = omdbEpCache[nowState.imdbID] || {};
        const entry = omdbEpCache[nowState.imdbID];
        if(nowState.totalSeasons) entry.totalSeasons = nowState.totalSeasons;
        saveEpCache();
      }

      saveNowState();
      updateNowPickerVisibility();
      renderNowHomeWidget();
      renderNow();
      toast("Смотрю сейчас", nowState.title || "Сериал");
    }
    function applyNowFromMovie(m){
      if(!m) return;
      const imdbID = m.omdb?.imdbID || null;
      if(!imdbID){
        toast("Нужен imdbID", "Добавь сериал через OMDb, чтобы подтянулись сезоны/серии.");
      }
      nowState.imdbID = imdbID;
      nowState.title = m.name || "";
      nowState.posterUrl = m.omdb?.posterUrl || null;
      nowState.startedAt = nowState.startedAt || Date.now();
      nowState.runtimeMin = parseRuntimeMinutes(m.omdb?.runtime) || nowState.runtimeMin;
      nowState.totalSeasons = null;
      nowState.watched = nowState.watched || {};
      // When selecting "now", optionally mark as active in wish: keep it but show via home widget
      saveNowState();

      // Smart queue: optional remove from wish if present? user said may move/mark active. We'll mark active with a flag on movie.
      try{
        m.isNow = true;
        saveMovies();
      }catch{}

      renderNowHomeWidget();
      renderNow();
      toast("Смотрю сейчас", nowState.title || "Сериал");
    }
function renderWishSeries(){ renderWishKind("series"); }


    // ========= Clear buttons =========
    els.clearAllRatedBtn.addEventListener("click", () => {
      const rated = movies.filter(m => (m.status || "watched") === "watched");
      if(rated.length === 0) return;
      if(confirm("Очистить все оценённые? Это действие нельзя отменить.")){
        movies = movies.filter(m => (m.status || "watched") !== "watched");
        saveMovies();
        renderEverything();
      }
    });

    els.clearAllWishMoviesBtn.addEventListener("click", () => {
      const wishMovies = movies.filter(m => (m.status || "watched") === "wish" && getWishKindForMovie(m) === "movie");
      if(wishMovies.length === 0) return;
      if(!confirm("Очистить очередь (фильмы)?")) return;
      movies = movies.filter(m => !((m.status || "watched") === "wish" && getWishKindForMovie(m) === "movie"));
      saveMovies();
      renderEverything();
      if(currentView === "wish") renderWish();
    });

    els.clearAllWishSeriesBtn.addEventListener("click", () => {
      const wishSeries = movies.filter(m => (m.status || "watched") === "wish" && getWishKindForMovie(m) === "series");
      if(wishSeries.length === 0) return;
      if(!confirm("Очистить очередь (сериалы)?")) return;
      movies = movies.filter(m => !((m.status || "watched") === "wish" && getWishKindForMovie(m) === "series"));
      saveMovies();
      renderEverything();
      if(currentView === "wish") renderWish();
    });

    if(els.wishMoviesRandomBtn){
      els.wishMoviesRandomBtn.addEventListener("click", () => pickRandomWish("movie"));
    }
    if(els.wishSeriesRandomBtn){
      els.wishSeriesRandomBtn.addEventListener("click", () => pickRandomWish("series"));
    }

    els.prevPageBtn.addEventListener("click", () => {
      ratedPage = Math.max(1, ratedPage - 1);
      renderRated();
    });
    els.nextPageBtn.addEventListener("click", () => {
      const list = getRatedFilteredSorted();
      const totalPages = Math.max(1, Math.ceil(list.length / PAGE_SIZE));
      ratedPage = Math.min(totalPages, ratedPage + 1);
      renderRated();
    });

    // rerender controls (rated)
    [els.search, els.sort, els.minAvg, els.tagFilter].forEach(el => {
      if(el.tagName === "SELECT") el.addEventListener("change", () => { ratedPage = 1; renderRated(); });
      else el.addEventListener("input", () => { ratedPage = 1; renderRated(); });
    });
    els.onlyFav.addEventListener("change", () => { ratedPage = 1; renderRated(); });

    
    // now controls
    if(els.nowPickFromWishBtn){
      els.nowPickFromWishBtn.addEventListener("click", () => {
        openPicker("wishSeries");
      });
    }

    if(els.nowDeleteActiveBtn){
      els.nowDeleteActiveBtn.addEventListener("click", () => {
        clearActiveNowSeries();
        toast("Удалено", "Активный сериал удалён из “Смотрю сейчас”.");
      });
    }

    // finished prompt actions
    const finishToEvaluate = document.getElementById("finishToEvaluate");
    const finishToRated = document.getElementById("finishToRated");
    const finishLater = document.getElementById("finishLater");
    const finishBox = document.getElementById("nowFinishedPrompt");

    if(finishToEvaluate){
      finishToEvaluate.addEventListener("click", () => {
        if(!nowState.imdbID) return;

        // Pre-fill "Оценить" and go there (НЕ на главную)
        goTo("evaluate");

        // Подставляем название/статус и OMDb-черновик (чтобы сохранился imdbID/постер)
        els.movieName.value = nowState.title || "";
        els.status.value = "watched";
        omdbMetaDraft = {
          imdbID: nowState.imdbID,
          posterUrl: nowState.posterUrl || null,
          runtime: nowState.runtimeMin ? (String(nowState.runtimeMin) + " min") : null,
          type: "series"
        };
        els.omdbStatus.textContent = "Подставлено из “Смотрю сейчас” (можно сразу оценивать)";

        // Закрываем плашку завершения и очищаем активный сериал ПОСЛЕ перехода
        nowState.finishDismissedFor = nowState.imdbID;
        saveNowState();
        clearNowSeries();

        toast("Готово", "Заполни оценки и нажми “Добавить”");
      });
    }

if(finishToRated){
      finishToRated.addEventListener("click", () => {
        if(!nowState.imdbID) return;

        // Move/ensure in rated list
        let existing = movies.find(x => x.omdb?.imdbID && x.omdb.imdbID === nowState.imdbID);
        if(existing){
          existing.status = "watched";
          existing.isNow = false;
        }else{
          existing = {
            id: makeId(),
            name: nowState.title || "Без названия",
            director: "",
            year: null,
            status: "watched",
            tags: [],
            notes: "",
            createdAt: Date.now(),
            scores: { ...DEFAULT_SCORES },
            favorite: false,
            queueOrder: null,
            omdb: { imdbID: nowState.imdbID, posterUrl: nowState.posterUrl || null, runtime: nowState.runtimeMin ? (String(nowState.runtimeMin) + " min") : null, type:"series" }
          };
          movies.push(existing);
        }
        saveMovies();

        // clear now
        clearActiveNowSeries();

        goTo("rated", { openId: existing.id });
        toast("Перемещено", "Сериал добавлен в “Оцененные”");
      });
    }

    if(finishLater){
      finishLater.addEventListener("click", () => {
        if(!nowState.imdbID) return;
        nowState.finishDismissedFor = nowState.imdbID;
        saveNowState();
        if(finishBox) finishBox.classList.add("hidden");
        toast("Ок", "Можно вернуться позже");
      });
    }

    // OMDb search (same UX as in "Оценить")
    if(els.nowPick){
      els.nowPick.addEventListener("input", scheduleNowOmdbAutocomplete);
      els.nowPick.addEventListener("keyup", scheduleNowOmdbAutocomplete);
      els.nowPick.addEventListener("change", scheduleNowOmdbAutocomplete);

      els.nowPick.addEventListener("keydown", async (e) => {
        if(e.key === "Escape"){
          nowHideOmdbResults();
          return;
        }
        if(e.key === "Enter"){
          if(els.nowOmdbResults?.classList.contains("show")){
            e.preventDefault();
            const first = els.nowOmdbResults.querySelector(".resItem");
            if(first) first.click();
            return;
          }
          // if no dropdown shown, run direct search
          nowSearchOmdb(els.nowPick.value);
        }
      });
    }

    if(els.nowOmdbSearchBtn){
      els.nowOmdbSearchBtn.addEventListener("click", () => nowSearchOmdb(els.nowPick?.value || ""));
    }

    if(els.nowApplyBtn){
      els.nowApplyBtn.addEventListener("click", async () => {
        const name = (els.nowPick?.value || "").trim();
        if(!name){
          toast("Введи название сериала 🙂");
          els.nowPick?.focus();
          return;
        }

        // 1) Try from твоей базы (очередь/оценённые)
        const m = findSeriesCandidateByName(name);
        if(m){
          applyNowFromMovie(m);
          goTo("now");
          return;
        }

        // 2) Fallback: OMDb (если сериал ещё не добавлен в библиотеку)
        toast("Ищу в OMDb…");
        try{
          const ok = await applyNowFromOmdbTitle(name);
          if(ok){
            goTo("now");
            return;
          }
          toast("Не найдено", "Попробуй уточнить название (на английском) или добавь через вкладку “Оценить”.");
        }catch{
          toast("OMDb недоступен", "Проверь интернет и попробуй ещё раз.");
        }
      });
    }

// wish controls
    els.wishMoviesSearch.addEventListener("input", renderWishMovies);
    els.wishSeriesSearch.addEventListener("input", renderWishSeries);

    // add buttons
    els.addBtn.addEventListener("click", addMovie);
    els.addWishBtn.addEventListener("click", addWishFromCurrentOmdb);
    els.resetBtn.addEventListener("click", resetSliders);

    if(els.tipsSendBtn){
      els.tipsSendBtn.addEventListener("click", requestTips);
    }

    if(els.tipsClearBtn){
      els.tipsClearBtn.addEventListener("click", () => {
        if(els.tipsOutput) els.tipsOutput.textContent = "Ответ появится здесь.";
        if(els.tipsStatus) els.tipsStatus.textContent = "Готов к новому запросу.";
      });
    }

    // ========= Init =========
    function renderEverything(){
      if(currentView === "home") renderHome();
      if(currentView === "rated") renderRated();
      if(currentView === "wish") renderWish();
      if(currentView === "wish") renderWish();
      if(currentView === "profile") renderProfile();
      if(currentView === "now") renderNow();
      if(currentView === "tips") renderTips();
      renderNowHomeWidget();
    }

  function init(){
  renderNav();
  renderSliders();
  updateTotals();
  renderHome();

  // Cinema night init
  const on = loadCinemaNight();
  applyCinemaNight(on);

  const cn = document.getElementById("cinemaNightToggle");
  if(cn){
    cn.checked = on;
    cn.addEventListener("change", () => {
      saveCinemaNight(cn.checked);
      applyCinemaNight(cn.checked);
      toast(cn.checked ? "Киноночь включена" : "Киноночь выключена");
    });
  }

  initSupabase();
}
init();

  </script>

  <datalist id="reasonSuggestions">
    <option value="Советовали"></option>
    <option value="Из-за актёра"></option>
    <option value="Из-за режиссёра"></option>
    <option value="Люблю такие сюжеты"></option>
    <option value="Похоже на мой любимый фильм"></option>
    <option value="Хочу пересмотреть"></option>
  </datalist>

  <div id="confettiLayer" class="confettiLayer" aria-hidden="true"></div>
  <div id="toastHost" class="toastHost"></div>
</body>
</html>
